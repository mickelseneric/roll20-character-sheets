//     Underscore.js 1.3.1
//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore is freely distributable under the MIT license.
//     Portions of Underscore are inspired or borrowed from Prototype,
//     Oliver Steele's Functional, and John Resig's Micro-Templating.
//     For all details and documentation:
//     http://documentcloud.github.com/underscore

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var slice            = ArrayProto.slice,
      unshift          = ArrayProto.unshift,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) { return new wrapper(obj); };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root['_'] = _;
  }

  // Current version.
  _.VERSION = '1.3.1';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  _.now = Date.now || function() {
    return new Date().getTime();
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    if (obj.length === +obj.length) results.length = obj.length;
    return results;
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError('Reduce of empty array with no initial value');
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var reversed = _.toArray(obj).reverse();
    if (context && !initial) iterator = _.bind(iterator, context);
    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    each(obj, function(value, index, list) {
      if (!iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if a given value is included in the array or object using `===`.
  // Aliased as `contains`.
  _.include = _.contains = function(obj, target) {
    var found = false;
    if (obj == null) return found;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    found = any(obj, function(value) {
      return value === target;
    });
    return found;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    return _.map(obj, function(value) {
      return (_.isFunction(method) ? method || value : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Return the maximum element or (element-based computation).
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj)) return Math.max.apply(Math, obj);
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj)) return Math.min.apply(Math, obj);
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var shuffled = [], rand;
    each(obj, function(value, index, list) {
      if (index == 0) {
        shuffled[0] = value;
      } else {
        rand = Math.floor(Math.random() * (index + 1));
        shuffled[index] = shuffled[rand];
        shuffled[rand] = value;
      }
    });
    return shuffled;
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, iterator, context) {
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria, b = right.criteria;
      return a < b ? -1 : a > b ? 1 : 0;
    }), 'value');
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, val) {
    var result = {};
    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
    each(obj, function(value, index) {
      var key = iterator(value, index);
      (result[key] || (result[key] = [])).push(value);
    });
    return result;
  };

  // Use a comparator function to figure out at what index an object should
  // be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator) {
    iterator || (iterator = _.identity);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >> 1;
      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(iterable) {
    if (!iterable)                return [];
    if (iterable.toArray)         return iterable.toArray();
    if (_.isArray(iterable))      return slice.call(iterable);
    if (_.isArguments(iterable))  return slice.call(iterable);
    return _.values(iterable);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    return _.toArray(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head`. The **guard** check allows it to work
  // with `_.map`.
  _.first = _.head = function(array, n, guard) {
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especcialy useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail`.
  // Especially useful on the arguments object. Passing an **index** will return
  // the rest of the values in the array from that index onward. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = function(array, index, guard) {
    return slice.call(array, (index == null) || guard ? 1 : index);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, function(value){ return !!value; });
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return _.reduce(array, function(memo, value) {
      if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));
      memo[memo.length] = value;
      return memo;
    }, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator) {
    var initial = iterator ? _.map(array, iterator) : array;
    var result = [];
    _.reduce(initial, function(memo, el, i) {
      if (0 == i || (isSorted === true ? _.last(memo) != el : !_.include(memo, el))) {
        memo[memo.length] = el;
        result[result.length] = array[i];
      }
      return memo;
    }, []);
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays. (Aliased as "intersect" for back-compat.)
  _.intersection = _.intersect = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = _.flatten(slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.include(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) results[i] = _.pluck(args, "" + i);
    return results;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i, l;
    if (isSorted) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);
    for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item) {
    if (array == null) return -1;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);
    var i = array.length;
    while (i--) if (i in array && array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Binding with arguments is also known as `curry`.
  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.
  // We check for `func.bind` first, to fail fast when `func` is undefined.
  _.bind = function bind(func, context) {
    if(!func) {
      return;
    }
    var bound, args;
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length == 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(func, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};

    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };

    var throttled = function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };

    throttled.cancel = function() {
      clearTimeout(timeout);
      previous = 0;
      timeout = context = args = null;
    };

    return throttled;
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds.
  _.debounce = function(func, wait) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        func.apply(context, args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      return memo = func.apply(this, arguments);
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func].concat(slice.call(arguments, 0));
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) { return func.apply(this, arguments); }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    return _.map(obj, _.identity);
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        if (obj[prop] == null) obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function.
  function eq(a, b, stack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a._chain) a = a._wrapped;
    if (b._chain) b = b._wrapped;
    // Invoke a custom `isEqual` method if one is provided.
    if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);
    if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = stack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (stack[length] == a) return true;
    }
    // Add the first object to the stack of traversed objects.
    stack.push(a);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          // Ensure commutative equality for sparse arrays.
          if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent.
      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    stack.pop();
    return result;
  }

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType == 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Is a given variable an arguments object?
  _.isArguments = function(obj) {
    return toString.call(obj) == '[object Arguments]';
  };
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Is a given value a function?
  _.isFunction = function(obj) {
    return toString.call(obj) == '[object Function]';
  };

  // Is a given value a string?
  _.isString = function(obj) {
    return toString.call(obj) == '[object String]';
  };

  // Is a given value a number?
  _.isNumber = function(obj) {
    return toString.call(obj) == '[object Number]';
  };

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return _.isNumber(obj) && isFinite(obj);
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    // `NaN` is the only value for which `===` is not reflexive.
    return obj !== obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value a date?
  _.isDate = function(obj) {
    return toString.call(obj) == '[object Date]';
  };

  // Is the given value a regular expression?
  _.isRegExp = function(obj) {
    return toString.call(obj) == '[object RegExp]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Has own property?
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function (n, iterator, context) {
    for (var i = 0; i < n; i++) iterator.call(context, i);
  };

  // Escape a string for HTML interpolation.
  _.escape = function(string) {
    return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g,'&#x2F;');
  };

  // Add your own custom functions to the Underscore object, ensuring that
  // they're correctly added to the OOP wrapper as well.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      addToWrapper(name, _[name] = obj[name]);
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = idCounter++;
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /.^/;

  // Within an interpolation, evaluation, or escaping, remove HTML escaping
  // that had been previously added.
  var unescape = function(code) {
    return code.replace(/\\\\/g, '\\').replace(/\\'/g, "'");
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(str, data) {
    var c  = _.templateSettings;
    var tmpl = 'var __p=[],print=function(){__p.push.apply(__p,arguments);};' +
      'with(obj||{}){__p.push(\'' +
      str.replace(/\\/g, '\\\\')
         .replace(/'/g, "\\'")
         .replace(c.escape || noMatch, function(match, code) {
           return "',_.escape(" + unescape(code) + "),'";
         })
         .replace(c.interpolate || noMatch, function(match, code) {
           return "'," + unescape(code) + ",'";
         })
         .replace(c.evaluate || noMatch, function(match, code) {
           return "');" + unescape(code).replace(/[\r\n\t]/g, ' ') + ";__p.push('";
         })
         .replace(/\r/g, '\\r')
         .replace(/\n/g, '\\n')
         .replace(/\t/g, '\\t')
         + "');}return __p.join('');";
    var func = new Function('obj', '_', tmpl);
    if (data) return func(data, _);
    return function(data) {
      return func.call(this, data, _);
    };
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // The OOP Wrapper
  // ---------------

  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.
  var wrapper = function(obj) { this._wrapped = obj; };

  // Expose `wrapper.prototype` as `_.prototype`
  _.prototype = wrapper.prototype;

  // Helper function to continue chaining intermediate results.
  var result = function(obj, chain) {
    return chain ? _(obj).chain() : obj;
  };

  // A method to easily add functions to the OOP wrapper.
  var addToWrapper = function(name, func) {
    wrapper.prototype[name] = function() {
      var args = slice.call(arguments);
      unshift.call(args, this._wrapped);
      return result(func.apply(_, args), this._chain);
    };
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      var wrapped = this._wrapped;
      method.apply(wrapped, arguments);
      var length = wrapped.length;
      if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];
      return result(wrapped, this._chain);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      return result(method.apply(this._wrapped, arguments), this._chain);
    };
  });

  // Start chaining a wrapped Underscore object.
  wrapper.prototype.chain = function() {
    this._chain = true;
    return this;
  };

  // Extracts the result from a wrapped and chained object.
  wrapper.prototype.value = function() {
    return this._wrapped;
  };

}).call(this);
/* eslint-disable no-undef */
import Observable from './util/Observable';
import * as d20math from './util/math';
import Matrix from './util/Matrix';
import Rectangle from './util/Rectangle';
import playerZoneHeight from './util/playerZoneHeight';
import stripTags from './util/stripTags';
import { getAccountFileSizeLimits, isFileSizeOverAccountSizeLimits } from './util/GetQuotaInformation';
import getS3Endpoint from './util/getS3Endpoint';

d20.utils = {
	SVG: {},
	stattracker: {},
	_hex_color_regex: /^#[0-9a-f]{6}$/i,
	_video_url_regex: /[\w\-]+\.webm/i,
	isVideo: url => d20.utils._video_url_regex.test(url),

	/**
	 * Capturing groups: 1: "dead", 2: hex color, 3: number to overlay
	 * @constant
	 * @private
	 */
	_status_regex: /^(?:(dead)|([^@]+)(?:@(\d))?)$/,

	/**
	 * @typedef StatusHash
	 * @type {object}
	 * @property {?string} dead - "dead" if the status type is dead.
	 * @property {?string} color - If the status is for a color, then this will be its hex code.
	 * @property {?number} icon - If the status is for an icon, then this will be its sheet index.
	 * @property {?string} number - String containing a single digit to be overlayed on top of the status icon/color.
	 */
	/**
	 * Get information about what this status name means.
	 * @param {string} status
	 * @return {StatusHash} Rendering data for this status.
	 */
	parseStatus: status => {
		const results = d20.utils._status_regex.exec(status);
		const status_hash = {
			dead: (results && results[1]) || null, // results[1] if defined, else null
			icon: null,
			color: null,
			number: (results && results[3]) || null // results[3] if defined, else null
		};
		if (results && results[2] && results[2] !== 'dead') {
			if (_.keys(d20.token_editor.colorMarkers).includes(results[2])) {
				status_hash.color = d20.token_editor.colorMarkers[results[2]];
			} else {
				const image = _.find(token_marker_array, (marker) => { return marker.tag === results[2] });
				if (!image) return false;
				status_hash.icon = image.id;
			}
		}
		return results && status_hash;
	},

	formattedBytes: (bytes) => {
		const units = ['B', 'KB', 'MB', 'GB', 'TB', 'PB'];
		let currentStepSize = bytes;
		let i = 0;

		for (i; currentStepSize > 1024; i += 1) {
			currentStepSize /= 1024;
		}

		return `${currentStepSize.toFixed(1)} ${units[i]}`;
	},

	getCorrectStatusName: status => {
		try {
			const results = d20.utils._status_regex.exec(status);
			if (_.keys(d20.token_editor.colorMarkers).includes(results[2])) {
				return status;
			}

			const tokenMarkerId = results[2] ? parseInt(_.last(results[2].split('::'))) : results[0];
			const marker = _.find(token_marker_array, (marker) => { return marker.id === tokenMarkerId });
			if (marker) {
				let correctName = marker.tag;
				if (results[3]) {
					correctName += `@${results[3]}`;
				}
				return correctName;
			}
			return status;
		} catch (e) {
			console.error(e);
			return status;
		}
	},

	Observable,

	isFileSizeOverAccountSizeLimits,
	getAccountFileSizeLimits,

	getS3Endpoint,
};

window["d20ext"] = window["d20ext"] || {};
window["d20ext"]["utils"] = d20.utils;

String.prototype.tranSub = function() {
	var oArguments = arguments;
	return this.replace(/{{[0-9]+}}/g, function(s) {
		return oArguments[parseInt(s.substring(2, s.length - 2))];
	});
};

d20.math = {
	...d20math,
	Matrix,
	Rectangle,
};

(function() {
	if (typeof JS_TRANSLATIONS !== 'undefined') {
		i18n.translator.add({
			values: JS_TRANSLATIONS
		});
	}
	var i18nOutputJSON = {};
	d20.utils.htmlTranslator = function($html, doDynamic) {
		if ($html === '') return '';
		if (typeof doDynamic === 'undefined') doDynamic = false;

		var returnType = 'jQuery';
		// creates jQuery obj if not already, but returns the type it's given
		if (typeof $html === 'string') {
			returnType = 'string';
			$html = $($html);
		}
		else if (!($html instanceof jQuery)) {
			returnType = 'html';
			$html = $($html);
		}
		var attributes = '[data-i18n],[data-i18n-placeholder],[data-i18n-title],[data-i18n-alt],[data-i18n-aria-label],[data-i18n-label]';
		if (doDynamic) attributes += ',[data-i18n-dynamic]';
		var listValidator = function(listValue) {
			var errorMessage = [];
			if (listValue === 'error') errorMessage.push('Missing list key.');
			if (listValue === '') errorMessage.push('Empty list entry.');

			if (errorMessage.length > 0) {
				return errorMessage.join(' ');
			}
			return false;
		};
		$html.find(attributes).each(function() {
			var $this = $(this);
			var options = ['-placeholder', '-title', '-alt', '-aria-label', '-label', ''];
			if (doDynamic) options.push('-dynamic');

			$.each(options, function() {
				try {
					if (typeof $this.attr('data-i18n' + this) === 'undefined') return;

					var i18nAttr = this !== '' ? this.substr(1) : false;
					var isDynamic = (doDynamic && i18nAttr === 'dynamic');
					var i18nKey = isDynamic ? $this.text() : $this.attr('data-i18n' + this);

					var i18nVars = ($this.attr('data-i18n-vars') || '').split('|');
					// if it is the text of an element we can highlight the text as a missing key with the extra span style, if it's attribute's text that won't work
					var i18nError = (i18nAttr ? '[' + i18nKey + ']' : '<span style="color: red;">[' + i18nKey + ']</span>');
					var i18nText = i18n(i18nKey, i18nError);

					i18nOutputJSON[i18nKey] = (i18nAttr ? $this.attr(i18nAttr) : $this.html());
					i18nText = (i18nVars.length === 0 ? i18nText : i18nText.replace(/{{([0-9]+)}}/g, function(x, $1) {
						// if the var is not defined, keep the match as-is. So it stays out of the way of roll templates as much as possible.
						return i18nVars[$1] ? i18nVars[$1] : '{{' + $1 + '}}';
					}));

					if (!i18nAttr || isDynamic) {
						$this.html(i18nText);
						// You cannot have both data-i18n and data-i18n-dynamic, they are at the end of the list, if either one runs we break out of the loop
						return false;
					}
					else {
						$this.attr(i18nAttr, i18nText);
					}
				}
				catch (e) {
					console.log('Translation Error:', e);
					console.log($this);
				}
			});
		});
		$html.find('[data-i18n-list]').each(function() {
			var $this = $(this);
			var i18nKey = $this.attr('data-i18n-list');
			var listValue = i18n(i18nKey, 'error');
			var listError = listValidator(listValue);

			if (listError) {
				$this.attr('data-i18n-error', listError);
				return;
			}

			var newListOrder = $.map(listValue.split(','), function(number) {
				return $.trim(number);
			});
			var listMax = $this.find('[data-i18n-list-item]').length;
			var $newList = $this.clone();
			var listError = false;

			if ($this.find('[data-i18n-list-item-num]').length > 0) {
				$.each(newListOrder, function(key, number) {
					if ($this.find('[data-i18n-list-item="' + newListOrder[key] + '"]').length === 0) {
						$this.attr('data-i18n-error', 'List does not contain the key: ' + newListOrder[key] + '.');
						listError = true;
						return;
					}
					$newList.find('[data-i18n-list-item-num="' + (key + 1) + '"]').replaceWith($this.find('[data-i18n-list-item="' + number + '"]').clone().removeAttr('data-i18n-list-item-num'));
				});
			}
			else {
				$newList.find('[data-i18n-list-item]').each(function(key) {
					if ($this.find('[data-i18n-list-item="' + newListOrder[key] + '"]').length === 0) {
						$this.attr('data-i18n-error', 'List does not contain the key: ' + newListOrder[key] + '.');
						listError = true;
						return;
					}
					$(this).replaceWith($this.find('[data-i18n-list-item="' + newListOrder[key] + '"]').clone().removeAttr('data-i18n-list-item'));
				});
			}
			if (!listError) {
				$this.replaceWith($newList);
			}
		});
		window.i18nOutput = JSON.stringify(i18nOutputJSON);
		switch (returnType) {
			case 'string':
				return $html.prop('outerHTML');
			case 'html':
				return $html[0];
			default:
				return $html;
		}
	};

	d20.utils.handleURLString = function(urlString, event) {
		const [url, queryParams = ''] = urlString.split("?");
		const [scheme, path, domainName, type, id] = url.split("/");

		if (domainName === "journal.roll20.net" || domainName === "wiki.roll20.net") {
			const item = d20.Campaign[type + "s"].get(id);
			if (item) {
				const inJournals = item.get("inplayerjournals").split(",");
				const currentPlayer = window.currentPlayer;
				const accessibleByAll = inJournals.includes("all");
				const accessibleByCurrentPlayer = currentPlayer && inJournals.includes(currentPlayer.id);
				
				if (
					window.is_gm 
					|| accessibleByAll 
					|| accessibleByCurrentPlayer
				) {
					if (type == "character" && item.attribs && item.abilities) {
						const charObj = item;
						const charAttribPromises = [];
						if (!charObj?.attribs?.backboneFirebase) {
							charObj.attribs.backboneFirebase = new BackboneFirebase(charObj.attribs);
							charAttribPromises.push(charObj.attribs.backboneFirebase.reference.once('value'));
						}
						if (!charObj?.abilities?.backboneFirebase) {
							charObj.abilities.backboneFirebase = new BackboneFirebase(charObj.abilities);
							charAttribPromises.push(charObj.abilities.backboneFirebase.reference.once('value'));
						}
						Promise.all(charAttribPromises).then(() => {
							item.view.showDialog();
						})
					} else {
						item.view.showDialog();
					};
				};
			};

			$("#existing" + type + "s").find("tr[data-" + type + "id=" + id + "]").trigger("click");

			return false
		};

		const compendiumURLRegex = /(?:(?:http(?:s?):\/\/(?:app\.)?roll20(?:staging)?\.(?:net|local:5000)\/|^\/?)compendium\/)([^\/]+)\/([^\/#?]+)/i
		const compendiumMatch = urlString.match(compendiumURLRegex);

		if (compendiumMatch) {
			const expansionId = queryParams.match(/expansion=(\d+)/)?.[1];
			const [, bookName, pageName] = compendiumMatch;
			d20.utils.openCompendiumPage(bookName, pageName, null, expansionId);

			event.stopPropagation();
			event.preventDefault();
			return;
		};

		if (urlString.indexOf("javascript:") !== -1) {
			return false;
		};

		//Allow us to link to API commands in the format [Button Text](!command)
		const urlSubString = urlString.substring(0, 1);
		switch(urlSubString) {
			case "`":
				d20.textchat.doChatInput(urlString.substring(1), 'link_click');
				return false;
				break;
			case "!":
				d20.textchat.doChatInput(urlString, 'api_link_click');
				return false;
				break;
			case "~":
				d20.textchat.doChatInput(
					"%{" + urlString.substring(1, urlString.length) + "}", 'link_click'
				);
				return false;
				break;
			default:
				break;
		}

		if (
			urlString === undefined 
			|| $(this).attr("rel") !== "external" && (urlString.indexOf("javascript:") !== -1 
			|| urlString.indexOf("://") === -1)) 
		{
			return;
		}

		event?.stopPropagation();
		event?.preventDefault();

		const dialog = $('<div class="dialog dialog-danger">' + urlString + '<br /><br />This link will open up a new window (or tab) to an external site. Just close the new window/tab to return to the editor.</div>');
		dialog.dialog({
			modal: true,
			title: "Confirm External Link",
			buttons: {
				"Continue": function() {
					$(this).dialog("destroy").remove();
					window.open(urlString);
				},
				"Cancel": function() {
					$(this).dialog("destroy").remove();
				}
			},
			beforeClose: function() {
				$(this).dialog("destroy").remove();
			}
		});
	}

	d20.utils.handleURL = function(e) {
		if ($(this).hasClass("lightly")) return;

		if ($(this).parents(".note-editable").length > 0) return;

		const url = $(this).attr("href");
		if (typeof url === "undefined") return false;

		return d20.utils.handleURLString(url, e);
	};

	d20.utils.openCompendiumPage = function(compendiumBookName, compendiumPageName, compendiumPageUniqueName = null, expansionId = '') {
		var addressName = compendiumPageName;
		var anchorName = "";
		if(compendiumPageUniqueName) {
			var split = compendiumPageUniqueName.split("#");
			addressName = split[0];
			anchorName = split[1] ? "#" + split[1] : "";
		}
		var maxwidth = 750;
		var maxheight = 800;
		var minheight = $(window).height() - 100;
		if (minheight > maxheight) {
			minheight = maxheight;
		}
		var minwidth = $(window).width() - 50;
		if (minwidth > maxwidth) {
			minwidth = maxwidth;
		}
		var $tempdialog = $(`<div class='compendiumpopup'><iframe src="${d20.compendium.compendiumBase}compendium/${compendiumBookName}/${addressName}?sharedCompendium=${campaign_id}&expansion=${expansionId}${anchorName}" style='width: 100%; height: calc(100% - 5px);' frameborder='0'></iframe></div>`);
		$tempdialog.dialog({
			modal: false,
			title: "<button class='showpopout btn pictos' style='margin-right: 15px;'>|</button>" + compendiumPageName.split(":")[0],
			beforeClose: function() {
				$tempdialog.dialog("destroy").remove();
			},
			resize: function() {
				$tempdialog.addClass('compendiumpopup100');
			},
			width: minwidth + 40,
			height: minheight,
			zIndex: 11000
		});

		var showCompendiumPopout = function() {
			var $prevdialog = $tempdialog;
			var winwidth = 900;
			var winheight = 750;

			winwidth = $prevdialog.width();
			winheight = $prevdialog.height();
			$prevdialog.dialog("close"); //this will totally remove the previous inframe and everything, but we can still re-append it as long as we have a reference to it

			var compendiumChildWindow = window.open("/editor/popout", "Popout" + (compendiumPageUniqueName || compendiumPageName), "menubar=0,location=0,toolbar=0,status=0,scrollbars=1,width=" + winwidth + ",height=" + winheight);
			window.allChildWindows.push(compendiumChildWindow);

			compendiumChildWindow.onload = function() {
				$prevdialog.appendTo(compendiumChildWindow.document.getElementById("containerdiv"));
				$prevdialog.show();
				compendiumChildWindow.document.title = compendiumPageName;
			}
			compendiumChildWindow.onbeforeunload = function() {
				window.allChildWindows = _.without(window.allChildWindows, othis.childWindow)
				compendiumChildWindow = null;
				$prevdialog.html("");
				$prevdialog = null;
			};
		}

		$tempdialog.parent().on("click", ".showpopout", function() {
			showCompendiumPopout();
		});
	};

	d20.utils.playerZoneHeight = playerZoneHeight;

	d20.utils.addImageProxy = (url) => {
		const match = url.toString();
		const noproxy = ['https://files.d20.io', 'http://imgsrv.roll20.net', 'https://imgsrv.roll20.net', imgsrv_url, 'https://app.roll20.net', 'https://storage.googleapis.com/char-sheet-app-images-6e101411'];

		for (let i = 0; i < noproxy.length; i++) {
			if (match.substring(0, noproxy[i].length) === noproxy[i]) {
				return match;
			}
		}

		if (/^https?:\/\//.test(match)) {
			return `${imgsrv_url}?src=${escape(match)}`;
		}

		return '';
	};

	d20.utils.strip_tags = stripTags;

	d20.utils.timeout = (ms) => {
		return new Promise(resolve => setTimeout(resolve, ms));
	};

	d20.utils.i18n = (key) => {
		return i18n(key);
	};

	d20.utils.htmlAllowed = "<code><span><div><label><a><br><br /><p><b><i><del><strike><u><img><video><audio><param><blockquote><mark><cite><small><ul><ol><li><hr><dl><dt><dd><sup><sub><big><pre><code><figure><figcaption><strong><em><table><tr><td><th><tbody><thead><tfoot><caption><h1><h2><h3><h4><h5><h6>";

	d20.utils.handleHTMLInput = function(input) {
		return escape(d20.utils.strip_tags(d20.utils.autoLink(input), d20.utils.htmlAllowed));
	};

	d20.utils.handleHTMLOutput = function(input, autolink) {
		return d20.utils.strip_tags(unescape(input), d20.utils.htmlAllowed);
	};

	d20.utils.showOverQuota = function() {
		var $dialog = $("<div><p>We're sorry, but it looks like you've uploaded more than your allotted quota of storage space on Roll20. You can increase your quota by <a href='/account/supporter/?quotainapp' target='_blank'>becoming a Plus user</a> (or upgrading your Plus account if you already have one), or by <a href='http://help.roll20.net/sidebar-art-library/' target='_blank'>deleting items from your Art Library</a>.</div>");
		$dialog.dialog({
			modal: true,
			title: "Quota Exceeded",
			buttons: {
				"Upgrade Account": function() {
					window.open("/account/supporter/?quotainapp");
					$dialog.dialog("destroy");
				},
				"No Thanks": function() {
					$dialog.dialog('destroy');
				}
			},
			beforeClose: function() {
				$dialog.dialog("destroy");
			}
		});
	};

	d20.utils.showQuotaBounce = function(size, available) {
		var $dialog = $(`<div><p>We're sorry, but it looks like this file would put you over your allotted quota of storage space on Roll20. The file is ${size} and your available space is ${available}. You can increase your quota by <a href='/account/supporter/?quotainapp' target='_blank'>becoming a Plus user</a> (or upgrading your Plus account if you already have one), or by <a href='https://help.roll20.net/hc/articles/360039675113-Art-Library#ArtLibrary-FreeingUpStorageSpace' target='_blank'>deleting items from your Art, Music, or PDF Library</a>.</div>`);
		$dialog.dialog({
			modal: true,
			title: "Quota Exceeded",
			buttons: {
				"Upgrade Account": function() {
					window.open("/account/supporter/?quotainapp");
					$dialog.dialog("destroy");
				},
				"No Thanks": function() {
					$dialog.dialog('destroy');
				}
			},
			beforeClose: function() {
				$dialog.dialog("destroy");
			}
		});
	};

	d20.utils.showBadConvert = function() {
		var $dialog = $("<div><p>There was an error trying to convert the PDF. Be sure you didn't specify an invalid page number. It's also possible the PDF is corrupted or isn't supported by our conversion software.</div>");
		$dialog.dialog({
			modal: true,
			title: "PDF Conversion Error",
			buttons: {
				"Drat!": function() {
					$dialog.dialog('destroy');
				}
			},
			beforeClose: function() {
				$dialog.dialog("destroy");
			}
		});
	};

	d20.utils.setupAvatar = function($el, othis) {
		$el.bind("uploadcomplete", function(e, response) {
			e.stopPropagation();
			if (response == "overquota") {
				d20.utils.showOverQuota();
				return false;
			}

			// var json = JSON.parse(response);
			// if(!json) {
			//     $el.find(".status").html("<div class='alert alert-danger'>Error uploading file. Pleaes try again.</div>");
			//     return;
			// }

			othis.updateModel();
			const responseImageURL =  response.base.replace('/original.', '/med.') + (response.base.indexOf('?') === -1 ? '?' + Math.floor(new Date().getTime() / 1000) : '');
			if ($el.hasClass('card_back')){
				othis.model.save({
					card_back: responseImageURL
				});
			} else if ($el.hasClass('avatar')){
				othis.model.save({
					avatar: responseImageURL
				});
			} else if ($el.hasClass('defaultToken')) {
				othis.saveDefaultTokenImage(responseImageURL);
			}
		});

		$el.dndUploader({
			url: "/image_library/newupload",
			method: "POST",
			allowMultiple: false
		});

		$el.bind("removeimage", function() {
			othis.updateModel();
			if ($el.hasClass('card_back')){
				othis.model.save({
					card_back: ""
				});
			} else if ($el.hasClass('avatar')){
				othis.model.save({
					avatar: ""
				});
			} else if ($el.hasClass('defaultToken')) {
				othis.removeDefaultToken();
			}
		});

		//Fixes https://github.com/Roll20/Collab/issues/4
		$el.on("click", ".remove", function() {
			$el.trigger("removeimage");
		})

		$el.droppable({
			drop: function(e, ui) {
				e.originalEvent.dropHandled = true;

				//$this.find(".bar").css("width", "100%");
				$el.trigger("uploadcomplete", [{
					base: ui.draggable.attr("data-fullsizeurl")
				}, true]);

				e.preventDefault();
				e.stopPropagation();
			},
			hoverClass: "drop-highlight",
			tolerance: "pointer",
			greedy: true,
			accept: ".resultimage, .library-item"
		});
	};

	d20.utils.summernoteInit = function() {
		let $textarea = $(this);
		let $loader = $("<div class=\"loader\"></div>");
		let showCodeView = $textarea.hasClass("code-view");
		let inAppEditor = $textarea.hasClass("in-app-editor");
		let callbacks = {};
		let toolbar = [
			["style", ["style"]],
			["font", ["bold", "italic", "underline", "strikethrough", "clear"]],
			["size", ["superscript", "subscript"]],
			["para", ["ol", "ul", "paragraph"]]
		];
		if (!inAppEditor) {
			toolbar.push(["insert", ["table", "link", "picture", "hr"]]);
			callbacks = {
				onImageUpload: function(files) {
					let $summernote = $(this);
					$loader.show();
					for (let i = 0; i < files.length; i++) {
						let name = files[i].name.split(".")[0];
						let data = new FormData();
						data.append("file", files[i]);
						$.ajax({
							data: data,
							dataType: "JSON",
							type: "POST",
							url: "/forum/upload",
							cache: false,
							contentType: false,
							processData: false,
							success: function(response) {
								if (typeof response.error !== "undefined") {
									alert(response.error);
									$loader.hide();
								}
								else {
									$summernote.summernote("insertImage", response["filelink"], name)
										.done(function() {
											$loader.hide();
										});
								}
							},
							error: function(jqXHR, textStatus, errorThrown) {
								alert("There was an error uploading your image. This was probably caused by either connection issues, or the file being too large.");
								$loader.hide();
							}
						});
					}
				},
				onImageUploadError: function(one, two, three) {
					console.error("Image Upload Error");
				}
			}
		}
		else {
			toolbar.push(["insert", ["link", "unlink"]]);
			toolbar.push(["hr", ["hr"]]);
			toolbar.push(["color", ["color"]]);
			toolbar.push(["tableAdd", ["table", "tableHeaders", "addRowUp", "addRowDown", "addColLeft", "addColRight"]]);
			toolbar.push(["tableDelete", ["deleteRow", "deleteCol", "deleteTable"]]);
		}
		if (showCodeView) {
			toolbar.push(["code", ["codeview"]])
		}
		let summernoteDefaults = {
			toolbar: toolbar,
			disableDragAndDrop: inAppEditor,
			callbacks: callbacks,
			maxHeight: 300,
			dialogsInBody: inAppEditor,
			onCreateLink: function (linkURL) {
				// If the URL is a special case, replace the : with html-escaped :
				if (linkURL[0] === "`" || linkURL[0] === "!" || linkURL[0] === "~") {
					linkURL = linkURL.replace(/:/g, "&#58;");
				}
				return linkURL;
			}
		}
		if (inAppEditor) {
			summernoteDefaults["popover"] = {
				table: [],
				link: []
			};
		}
		else {
			summernoteDefaults["popover"] = {
				table: [
					['add', ['tableHeaders', 'addRowDown', 'addRowUp', 'addColLeft', 'addColRight']],
					['delete', ['deleteRow', 'deleteCol', 'deleteTable']]
				]
			}
		}

		$textarea.summernote(summernoteDefaults);
		$loader.hide();
		$textarea.siblings(".note-editor").append($loader);
	};

	d20.utils.summernoteDeInit = function (dialog){
		$(dialog).find('.summernote').each((index, summernote) => {
			$(summernote).summernote('destroy');
		});
	}

	d20.utils.makeContentEditable = function($container, content, includeCodeView) {
		let $content = $(content);
		$container.html("<textarea class='summernote" + (includeCodeView ? " code-view" : "") + "'></textarea>");
		$container.find("textarea.summernote").each(d20.utils.summernoteInit);
		$container.find("textarea.summernote").summernote("focus");
		$content.find(".lightly").each(function() {
			let $imgWrapper = $(this);
			let $img = $($imgWrapper.html());
			$imgWrapper.after($img);
			$imgWrapper.remove();
		});
		$container.find(".note-editable").html($content.html());
		$container.find("textarea.summernote").trigger("summernote.change");
	};

	d20.utils.addCSSRules = function(rules) {
		// make a new stylesheet
		var ns = document.createElement('style');
		document.getElementsByTagName('head')[0].appendChild(ns);

		// Safari does not see the new stylesheet unless you append something.
		// However!  IE will blow chunks, so ... filter it thusly:
		if (!window.createPopup) {
			ns.appendChild(document.createTextNode(''));
		}
		var s = document.styleSheets[document.styleSheets.length - 1];
		// some rules to apply

		// loop through and insert
		for (let selector in rules) {
			if (s.insertRule) {
				// it's an IE browser
				try {
					s.insertRule(selector + rules[selector], s.cssRules.length);
				}
				catch (e) {}
			}
			else {
				// it's a W3C browser
				try {
					s.addRule(selector, rules[selector]);
				}
				catch (e) {
					console.log("Error addding rule!");
					console.log(e);
				}
			}
		}
	};

	d20.utils.defaultDiceTokens = {
		//"d4": ["https://files.d20.io/images/747303/YxmOG16zPFiSrW-lEdmpTg/thumb.png?1362453271", "https://files.d20.io/images/747301/kMSch19zUnLoGoySwF9Ykw/thumb.png?1362453271", "https://files.d20.io/images/747302/ENrfFRhP2pDdneKgT6Jgxg/thumb.png?1362453271", "https://files.d20.io/images/747304/aZ8KB0ptksJcgRQx8gMS2w/thumb.png?1362453271"],
		//"d20": ["https://files.d20.io/images/747271/vPvYG84j2tSSpZ48D3eNqQ/thumb.png?1362453151", "https://files.d20.io/images/747272/6BPnNW3PBEhPclkb-xIQ9w/thumb.png?1362453151", "https://files.d20.io/images/747274/MzYLKWK5SVhbdvJ8napIzQ/thumb.png?1362453151", "https://files.d20.io/images/747273/K0Lx76PSDaAQdNjWmoXang/thumb.png?1362453151", "https://files.d20.io/images/747276/Q72SEogE5fqO6v6aMCBUPw/thumb.png?1362453152", "https://files.d20.io/images/747275/aRwPAppIFt7HPM5C6y0lQQ/thumb.png?1362453152", "https://files.d20.io/images/747277/beOPJkwPA4PRV4QLq7byOg/thumb.png?1362453152", "https://files.d20.io/images/747278/5j5CigYBAP3DG-cNrHQ_FQ/thumb.png?1362453152", "https://files.d20.io/images/747282/RWTJJTPcxOvZNQGCaBiQcg/thumb.png?1362453153", "https://files.d20.io/images/747280/J5X-7rRBuaOVzKCXgJWYnQ/thumb.png?1362453153", "https://files.d20.io/images/747281/_bVtu7w2FZoYJ95iANudJg/thumb.png?1362453153", "https://files.d20.io/images/747279/H4wLbu2fcIqjXaBNR8F0ZQ/thumb.png?1362453153", "https://files.d20.io/images/747284/FzVdwcAZVuCyzHGlEQuSEg/thumb.png?1362453154", "https://files.d20.io/images/747283/mSSjECWXrGoUpWWpRrWpGw/thumb.png?1362453154", "https://files.d20.io/images/747288/a8LXJpE19UPpMTQ8Zw6q-w/thumb.png?1362453155", "https://files.d20.io/images/747285/t1hwT9c3lrDYxqItfXYmGw/thumb.png?1362453154", "https://files.d20.io/images/747287/wr35rz8yLjQkyiQKBKRR9A/thumb.png?1362453155", "https://files.d20.io/images/747290/d3_6X1wnx1M_qe3wpBXu8Q/thumb.png?1362453156", "https://files.d20.io/images/747291/0uDnSVP2vb51jgcjqe3KAA/thumb.png?1362453158", "https://files.d20.io/images/747289/juvZAZ00F_AETQb4g4lV3w/thumb.png?1362453155"]
		"d4": ["https://files.d20.io/images/779542/DEYaBdP8w9B1CUSK26im0A/thumb.png?1363050056", "https://files.d20.io/images/779540/P7yKde5fyGZCB1ud70UOzA/thumb.png?1363050056", "https://files.d20.io/images/779539/AO4m-45bGw5yOcnZXUAn9g/thumb.png?1363050056", "https://files.d20.io/images/779541/oWA-hmBAHNAijceHr8k-3A/thumb.png?1363050056"],
		"d6": ["https://files.d20.io/images/779533/-gS85HUaXIvmE5SjGpoH4w/thumb.png?1363049998", "https://files.d20.io/images/779535/vkc_PT4z-d_ON1MvfHaCiA/thumb.png?1363049999", "https://files.d20.io/images/779534/mHDadFirie4L12_ii-HYqQ/thumb.png?1363049998", "https://files.d20.io/images/779531/nXqp2BhdwVsQn7cDR3cMlg/thumb.png?1363049998", "https://files.d20.io/images/779532/nQD5_IXYLWN7YCjnd5zugA/thumb.png?1363049998", "https://files.d20.io/images/779536/ttiwwiWE2PVkhD2d7fV3GA/thumb.png?1363049999"],
		"d8": ["https://files.d20.io/images/779514/GPCh5vqdSwvt_ANka3yhaw/thumb.png?1363049802", "https://files.d20.io/images/779517/nnuf1Pe2Fq70BIs9FGI7mQ/thumb.png?1363049802", "https://files.d20.io/images/779516/WnwuwT7yb5VM3-KiJY3GOg/thumb.png?1363049802", "https://files.d20.io/images/779515/Gx21buVd6d6onPsALrGFWQ/thumb.png?1363049802", "https://files.d20.io/images/779518/4LqfUGiX8sBXrX9b5gUnLw/thumb.png?1363049803", "https://files.d20.io/images/779519/YOR5Wav0-3-L1fm4vD-LFQ/thumb.png?1363049803", "https://files.d20.io/images/779522/dGFXXsEJz0EPA8dRpZvOzA/thumb.png?1363049804", "https://files.d20.io/images/779521/QXm6GcIhK6zTdMvJZVS8Og/thumb.png?1363049804"],
		"d10": ["https://files.d20.io/images/779498/fjup5Fz4iV-TFKxV9z1Qtg/thumb.png?1363049717", "https://files.d20.io/images/779500/ug7m7g1rII05ZFzyTrkRmw/thumb.png?1363049717", "https://files.d20.io/images/779499/QNZR5kGieM1x00yQvSYYbg/thumb.png?1363049717", "https://files.d20.io/images/779497/tkz2552-MqV8a_woAD8S4A/thumb.png?1363049717", "https://files.d20.io/images/779501/xKjqIxXzibpcx3Lp7UH6qg/thumb.png?1363049718", "https://files.d20.io/images/779502/Bpc1QATzO293LvGS3neBsQ/thumb.png?1363049718", "https://files.d20.io/images/779504/Bpw24T8na0nJNFdTKZX5aw/thumb.png?1363049718", "https://files.d20.io/images/779503/ukQbc7uDKfl62ng2EO6h6g/thumb.png?1363049719", "https://files.d20.io/images/779505/23948Y6_O0Bc0RuIve3BbA/thumb.png?1363049719", "https://files.d20.io/images/779506/VhwbFVDm2KOte5h2p97n7w/thumb.png?1363049719"],
		"d12": ["https://files.d20.io/images/779476/FRkaR6XvyzUuZb0ZB7ysCA/thumb.png?1363049489", "https://files.d20.io/images/779474/UyTKDHxf-fU1zC3w6udl0w/thumb.png?1363049489", "https://files.d20.io/images/779475/kUK2UmBaD2No00Gp4Q_OCQ/thumb.png?1363049489", "https://files.d20.io/images/779477/OVnJDjAkMPLk29hjpFjUvw/thumb.png?1363049489", "https://files.d20.io/images/779478/2la9taZk_vqdKItYZ6JEfA/thumb.png?1363049490", "https://files.d20.io/images/779479/fa8f9OVIBt79oETji8C8Lg/thumb.png?1363049490", "https://files.d20.io/images/779480/CTuw9Yiijq24ra3G9YMuPA/thumb.png?1363049490", "https://files.d20.io/images/779481/d4onnc7NOAbNG5JbiL9mbg/thumb.png?1363049491", "https://files.d20.io/images/779482/Oy2dTkB3-NlxiMsTRj78nw/thumb.png?1363049491", "https://files.d20.io/images/779483/mO_KU8nlO7GDQKc2J_aNeg/thumb.png?1363049491", "https://files.d20.io/images/779484/3MYG5dYJhiKXsRZtSUpHZw/thumb.png?1363049491", "https://files.d20.io/images/779485/VxA3umVDmYrH5A_VBecUIQ/thumb.png?1363049492"],
		"d20": ["https://files.d20.io/images/779445/OfLXGnbkNr2qKg1Qqk4cPg/thumb.png?1363049314", "https://files.d20.io/images/779447/br4TdShbuMIZ-D-lyeXsKA/thumb.png?1363049315", "https://files.d20.io/images/779454/2ARsJLoP4tExbCWrRaaxQg/thumb.png?1363049318", "https://files.d20.io/images/779444/3pryVOKRxMCBisEHpH3LWg/thumb.png?1363049314", "https://files.d20.io/images/779446/Yk4sSF3eWfnpeJd4DQpV2A/thumb.png?1363049314", "https://files.d20.io/images/779450/tdvjVviFHhM_KxjFRQomhA/thumb.png?1363049316", "https://files.d20.io/images/779456/twbHlPq0CFjFCpAyS59CTQ/thumb.png?1363049319", "https://files.d20.io/images/779449/PPHDirZfEowhjBHxQdxJiw/thumb.png?1363049315", "https://files.d20.io/images/779448/1SpNrrunpHwrNbsKcqpCzQ/thumb.png?1363049315", "https://files.d20.io/images/779458/VsueBYqaDlvp9BjlXl9wMQ/thumb.png?1363049320", "https://files.d20.io/images/779451/nWqhH9iMimUAJh_9jOFEog/thumb.png?1363049316", "https://files.d20.io/images/779452/TvksvU6AZm2wmpEQ2HkBlQ/thumb.png?1363049317", "https://files.d20.io/images/779459/L4pwmqIbQk0TfaCMExrYxQ/thumb.png?1363049320", "https://files.d20.io/images/779453/MDmeMWOQ_lARfvFoT1n3KQ/thumb.png?1363049317", "https://files.d20.io/images/779460/my8VEGyYcJIHZN2uXP6QXQ/thumb.png?1363049321", "https://files.d20.io/images/779455/nuz5AefdQSB6H4mvUXoqhw/thumb.png?1363049318", "https://files.d20.io/images/779457/kQBunq7iXGmHNqZQCa5MCA/thumb.png?1363049319", "https://files.d20.io/images/779463/6n_z7Gwd7eacm3-HC-f-mg/thumb.png?1363049322", "https://files.d20.io/images/779462/aVz3qCe2QM2nWhn3BoT9rg/thumb.png?1363049321", "https://files.d20.io/images/779461/4PuFJYddJWJjj4uL5S3mxQ/thumb.png?1363049321"]
	}

	for (var ddt in d20.utils.defaultDiceTokens) {
		d20.utils.defaultDiceTokens[ddt] = _.map(d20.utils.defaultDiceTokens[ddt], function(item) {
			return escape(item + "");
		})
	}

	d20.utils.hexToRgb = function(h) {
		h[4] || (h = h.replace(/./g, '$&$&').slice(1));
		return ['0x' + h[1] + h[2] | 0, '0x' + h[3] + h[4] | 0, '0x' + h[5] + h[6] | 0]
	};

	var linkCache = {};

	var _refreshLinkCache = function() {
		var possibilities = {};
		d20.Campaign.characters.each(function(character) {
			var injournals = character.get("inplayerjournals").split(",");
			if (window.is_gm || _.indexOf(injournals, "all") !== -1 || (window.currentPlayer && _.indexOf(injournals, window.currentPlayer.id) !== -1)) {
				possibilities[character.get("name").toLowerCase()] = {
					type: "character",
					id: character.id
				};
			}
		});

		d20.Campaign.handouts.each(function(handout) {
			var injournals = handout.get("inplayerjournals").split(",");
			if (window.is_gm || _.indexOf(injournals, "all") !== -1 || (window.currentPlayer && _.indexOf(injournals, window.currentPlayer.id) !== -1)) {
				possibilities[handout.get("name").toLowerCase()] = {
					type: "handout",
					id: handout.id
				};
			}
		});

		d20.Campaign.pdfs.each(function(pdf) {
			var injournals = pdf.get("inplayerjournals").split(",");
			if (window.is_gm || _.indexOf(injournals, "all") !== -1 || (window.currentPlayer && _.indexOf(injournals, window.currentPlayer.id) !== -1)) {
				possibilities[pdf.get("name").toLowerCase()] = {
					type: "pdf",
					id: pdf.id
				};
			}
		});
		linkCache = possibilities;
	};

	d20.utils.refreshLinkCache = _.debounce(_refreshLinkCache, 100);

	d20.utils.autoLink = function(text) {
		var linkreg = /\[[^\]]+\]/g
		text = text.replace(linkreg, function(match) {
			match = match.substring(1, match.length - 1);
			var foundmatch = linkCache[match.toLowerCase()];
			if (foundmatch) {
				return "<a href='http://journal.roll20.net/" + foundmatch.type + "/" + foundmatch.id + "'>" + match + "</a>";
			}
			else {
				return "[" + match + "]";
			}
		});
		return text;
	};

	var $notifier = $("#textchat-notifier");

	var currentTextchatNotificationPermanent = false;

	d20.utils.textchatNotify = function(msg, permanent) {

		if (currentTextchatNotificationPermanent === true && permanent !== true) return; //ignore non-permanent messages

		if (msg === false) {
			$notifier.hide();
		}
		else {
			$notifier.show().text(msg);
		}

		if (permanent === true) {
			if (msg !== false) currentTextchatNotificationPermanent = true;
			else currentTextchatNotificationPermanent = false;
		}
	}

	d20.utils.getParentsUntil = function(elem, parent, selector) {

		var parents = [];
		// if ( parent ) {
		//     var parentType = parent.charAt(0);
		// }
		if (selector) {
			var selectorType = selector.charAt(0);
		}

		// Get matches
		for (; elem && elem !== document; elem = elem.parentNode) {

			// Check if parent has been reached
			// if ( parent ) {

			//     // If parent is a class
			//     if ( parentType === '.' ) {
			//         if ( elem.classList.contains( parent.substr(1) ) ) {
			//             break;
			//         }
			//     }

			//     // If parent is an ID
			//     if ( parentType === '#' ) {
			//         if ( elem.id === parent.substr(1) ) {
			//             break;
			//         }
			//     }

			//     // If parent is a data attribute
			//     if ( parentType === '[' ) {
			//         if ( elem.hasAttribute( parent.substr(1, parent.length - 1) ) ) {
			//             break;
			//         }
			//     }

			//     // If parent is a tag
			//     if ( elem.tagName.toLowerCase() === parent ) {
			//         break;
			//     }

			// }

			if (parent) {
				if (parent === elem) {
					break;
				}
			}

			if (selector) {

				// If selector is a class
				if (selectorType === '.') {
					if (elem.classList.contains(selector.substr(1))) {
						parents.push(elem);
					}
				}

				// If selector is an ID
				if (selectorType === '#') {
					if (elem.id === selector.substr(1)) {
						parents.push(elem);
					}
				}

				// If selector is a data attribute
				if (selectorType === '[') {
					if (elem.hasAttribute(selector.substr(1, selector.length - 1))) {
						parents.push(elem);
					}
				}

				// If selector is a tag
				if (elem.tagName.toLowerCase() === selector) {
					parents.push(elem);
				}

			}
			else {
				parents.push(elem);
			}

		}

		return parents;

	};
})();

window.ucfirst = function(string) {
	return string.charAt(0).toUpperCase() + string.slice(1);
};

/*!
 Author: Stephen Korecky
 Website: http://stephenkorecky.com
 Plugin Website: http://github.com/skorecky/Add-Clear
 Version: 2.0.5
 The MIT License (MIT)
 Copyright (c) 2015 Stephen Korecky
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

;
(function($, window, document, undefined) {

	// Create the defaults once
	var pluginName = "addClear",
		defaults = {
			closeSymbol: "&#10006;",
			color: "#CCC",
			top: -1,
			right: 8,
			returnFocus: true,
			showOnLoad: false,
			onClear: null,
			hideOnBlur: false,
			tabbable: true
		};

	// The actual plugin constructor
	function Plugin(element, options) {
		this.element = element;

		this.options = $.extend({}, defaults, options);

		this._defaults = defaults;
		this._name = pluginName;

		this.init();
	}

	Plugin.prototype = {

		init: function() {
			var $this = $(this.element),
				$clearButton,
				me = this,
				options = this.options;

			$this.wrap("<span style='position:relative;' class='add-clear-span'></span>");
			var tabIndex = options.tabbable ? "" : " tabindex='-1'";
			$clearButton = $("<a href='#clear' style='display: none;'" + tabIndex + ">" + options.closeSymbol + "</a>");
			$this.after($clearButton);
			$this.next().css({
				color: options.color,
				'text-decoration': 'none',
				display: 'none',
				'line-height': 1,
				overflow: 'hidden',
				position: 'absolute',
				right: options.right,
				top: options.top
			}, this);

			if ($this.val().length >= 1 && options.showOnLoad === true) {
				$clearButton.css({
					display: 'block'
				});
			}

			$this.focus(function() {
				if ($(this).val().length >= 1) {
					$clearButton.css({
						display: 'block'
					});
				}
			});

			$this.blur(function(e) {
				if (options.hideOnBlur) {
					setTimeout(function() {
						var relatedTarget = e.relatedTarget || e.explicitOriginalTarget || document.activeElement;
						if (relatedTarget !== $clearButton[0]) {
							$clearButton.css({
								display: 'none'
							});
						}
					}, 0);
				}
			});

			var handleUserInput = function() {
				if ($(this).val().length >= 1) {
					$clearButton.css({
						display: 'block'
					});
				}
				else {
					$clearButton.css({
						display: 'none'
					});
				}
			};

			var handleInput = function() {
				$this.off('keyup', handleUserInput);
				$this.off('cut', handleUserInput);
				handleInput = handleUserInput;
				handleUserInput.call(this);
			};

			$this.on('keyup', handleUserInput);

			$this.on('cut', function() {
				var self = this;
				setTimeout(function() {
					handleUserInput.call(self);
				}, 0);
			});

			$this.on('input', function() {
				handleInput.call(this);
			});

			if (options.hideOnBlur) {
				$clearButton.blur(function() {
					$clearButton.css({
						display: 'none'
					});
				});
			}

			$clearButton.click(function(e) {
				var $input = $(me.element);
				$input.val("").trigger("keyup");
				$(this).css({
					display: 'none'
				});
				if (options.returnFocus === true) {
					$input.focus();
				}
				if (options.onClear) {
					options.onClear($input);
				}
				e.preventDefault();
			});
		}

	};

	$.fn[pluginName] = function(options) {
		return this.each(function() {
			if (!$.data(this, "plugin_" + pluginName)) {
				$.data(this, "plugin_" + pluginName,
					new Plugin(this, options));
			}
		});
	};

})(jQuery, window, document);
// seedrandom.js version 2.0.
// Author: David Bau 4/2/2011
//
// Defines a method Math.seedrandom() that, when called, substitutes
// an explicitly seeded RC4-based algorithm for Math.random().  Also
// supports automatic seeding from local or network sources of entropy.
//
// Usage:
//
//   <script src=http://davidbau.com/encode/seedrandom-min.js></script>
//
//   Math.seedrandom('yipee'); Sets Math.random to a function that is
//                             initialized using the given explicit seed.
//
//   Math.seedrandom();        Sets Math.random to a function that is
//                             seeded using the current time, dom state,
//                             and other accumulated local entropy.
//                             The generated seed string is returned.
//
//   Math.seedrandom('yowza', true);
//                             Seeds using the given explicit seed mixed
//                             together with accumulated entropy.
//
//   <script src="http://bit.ly/srandom-512"></script>
//                             Seeds using physical random bits downloaded
//                             from random.org.
//
//   <script src="https://jsonlib.appspot.com/urandom?callback=Math.seedrandom">
//   </script>                 Seeds using urandom bits from call.jsonlib.com,
//                             which is faster than random.org.
//
// Examples:
//
//   Math.seedrandom("hello");            // Use "hello" as the seed.
//   document.write(Math.random());       // Always 0.5463663768140734
//   document.write(Math.random());       // Always 0.43973793770592234
//   var rng1 = Math.random;              // Remember the current prng.
//
//   var autoseed = Math.seedrandom();    // New prng with an automatic seed.
//   document.write(Math.random());       // Pretty much unpredictable.
//
//   Math.random = rng1;                  // Continue "hello" prng sequence.
//   document.write(Math.random());       // Always 0.554769432473455
//
//   Math.seedrandom(autoseed);           // Restart at the previous seed.
//   document.write(Math.random());       // Repeat the 'unpredictable' value.
//
// Notes:
//
// Each time seedrandom('arg') is called, entropy from the passed seed
// is accumulated in a pool to help generate future seeds for the
// zero-argument form of Math.seedrandom, so entropy can be injected over
// time by calling seedrandom with explicit data repeatedly.
//
// On speed - This javascript implementation of Math.random() is about
// 3-10x slower than the built-in Math.random() because it is not native
// code, but this is typically fast enough anyway.  Seeding is more expensive,
// especially if you use auto-seeding.  Some details (timings on Chrome 4):
//
// Our Math.random()            - avg less than 0.002 milliseconds per call
// seedrandom('explicit')       - avg less than 0.5 milliseconds per call
// seedrandom('explicit', true) - avg less than 2 milliseconds per call
// seedrandom()                 - avg about 38 milliseconds per call
//
// LICENSE (BSD):
//
// Copyright 2010 David Bau, all rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
//   1. Redistributions of source code must retain the above copyright
//      notice, this list of conditions and the following disclaimer.
//
//   2. Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
// 
//   3. Neither the name of this module nor the names of its contributors may
//      be used to endorse or promote products derived from this software
//      without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
/**
 * All code is in an anonymous closure to keep the global namespace clean.
 *
 * @param {number=} overflow 
 * @param {number=} startdenom
 */
(function (pool, math, width, chunks, significance, overflow, startdenom) {


//
// seedrandom()
// This is the seedrandom function described above.
//
math['seedrandom'] = function seedrandom(seed, use_entropy) {
  var key = [];
  var arc4;

  // Flatten the seed string or build one from local entropy if needed.
  seed = mixkey(flatten(
    use_entropy ? [seed, pool] :
    arguments.length ? seed :
    [new Date().getTime(), pool, window], 3), key);

  // Use the seed to initialize an ARC4 generator.
  arc4 = new ARC4(key);

  // Mix the randomness into accumulated entropy.
  mixkey(arc4.S, pool);

  // Override Math.random

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.

  math['random'] = function random() {  // Closure to return a random double:
    var n = arc4.g(chunks);             // Start with a numerator n < 2 ^ 48
    var d = startdenom;                 //   and denominator d = 2 ^ 48.
    var x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };
    
  /*
   * Added by Eric Dalquist, uses the same logic as Java's Math.nextInt(n) to make
   * sure that the random values are evently distributed across the space
   */
  var randomInt = function randomInt(n) {
     
      if (n < 0) {
        throw "n must be non-negative"
      }
      // Determine the number of counts needed to generate a the number, minimum is 1
      var counts = Math.max(Math.ceil(Math.log(n) / Math.log(width)), 1);
      
      // If counts is greater than 6 then maxRand is greater than 2^53 which is the
      // largest safe int in JavaScript. This library cannot generate random ints larger
      // than width^chunks
      if (counts > chunks) {
        throw "n cannot be greater than " + width + "^" + chunks;
      }

      // Calculate the maximum random number possible for the counts
      var maxRnd = Math.pow(width, counts);     

      // Calculate the maximum valid random number to prevent uneven distribution    
      var maxValid = n * Math.floor(maxRnd / n);
      var rnd;
      var pass = 0;
      do {
          rnd = arc4.g(counts);
          pass++;
      } while (rnd >= maxValid && pass < 100);    // Ignore numbers that are outside of the valid range
      
      return rnd % n;
  };

  Math["randomInt"] = randomInt;

  // Return randomInt function?
  return randomInt;
};

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
/** @constructor */
function ARC4(key) {
  var t, u, me = this, keylen = key.length;
  var i = 0, j = me.i = me.j = me.m = 0;
  me.S = [];
  me.c = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) { me.S[i] = i++; }
  for (i = 0; i < width; i++) {
    t = me.S[i];
    j = lowbits(j + t + key[i % keylen]);
    u = me.S[j];
    me.S[i] = u;
    me.S[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  me.g = function getnext(count) {
    var s = me.S;
    var i = lowbits(me.i + 1); var t = s[i];
    var j = lowbits(me.j + t); var u = s[j];
    s[i] = u;
    s[j] = t;
    var r = s[lowbits(t + u)];
    while (--count) {
      i = lowbits(i + 1); t = s[i];
      j = lowbits(j + t); u = s[j];
      s[i] = u;
      s[j] = t;
      r = r * width + s[lowbits(t + u)];
    }
    me.i = i;
    me.j = j;
    return r;
  };
  // For robust unpredictability discard an initial batch of values.
  // See http://www.rsa.com/rsalabs/node.asp?id=2009
  me.g(width);
}

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
/** @param {Object=} result 
  * @param {string=} prop
  * @param {string=} typ */
function flatten(obj, depth, result, prop, typ) {
  result = [];
  typ = typeof(obj);
  if (depth && typ == 'object') {
    for (prop in obj) {
      if (prop.indexOf('S') < 5) {    // Avoid FF3 bug (local/sessionStorage)
        try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
      }
    }
  }
  return (result.length ? result : obj + (typ != 'string' ? '\0' : ''));
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
/** @param {number=} smear 
  * @param {number=} j */
function mixkey(seed, key, smear, j) {
  seed += '';                         // Ensure the seed is a string
  smear = 0;
  for (j = 0; j < seed.length; j++) {
    key[lowbits(j)] =
      lowbits((smear ^= key[lowbits(j)] * 19) + seed.charCodeAt(j));
  }
  seed = '';
  for (j in key) { seed += String.fromCharCode(key[j]); }
  return seed;
}

//
// lowbits()
// A quick "n mod width" for width a power of 2.
//
function lowbits(n) { return n & (width - 1); }

//
// The following constants are related to IEEE 754 limits.
//
startdenom = math.pow(width, chunks);
significance = math.pow(2, significance);
overflow = significance * 2;

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to intefere with determinstic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

// End anonymous scope, and pass initial values.
})(
  [],   // pool: entropy pool starts empty
  Math, // math: package containing random, pow, and seedrandom
  256,  // width: each RC4 output is 0 <= x < 256
  6,    // chunks: at least six RC4 outputs for each double
  52    // significance: there are 52 significant digits in a double
);
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
var dbits;var canary=244837814094590;var j_lm=((canary&16777215)==15715070);function BigInteger(e,d,f){if(e!=null){if("number"==typeof e){this.fromNumber(e,d,f)}else{if(d==null&&"string"!=typeof e){this.fromString(e,256)}else{this.fromString(e,d)}}}}function nbi(){return new BigInteger(null)}function am1(f,a,b,e,h,g){while(--g>=0){var d=a*this[f++]+b[e]+h;h=Math.floor(d/67108864);b[e++]=d&67108863}return h}function am2(f,q,r,e,o,a){var k=q&32767,p=q>>15;while(--a>=0){var d=this[f]&32767;var g=this[f++]>>15;var b=p*d+g*k;d=k*d+((b&32767)<<15)+r[e]+(o&1073741823);o=(d>>>30)+(b>>>15)+p*g+(o>>>30);r[e++]=d&1073741823}return o}function am3(f,q,r,e,o,a){var k=q&16383,p=q>>14;while(--a>=0){var d=this[f]&16383;var g=this[f++]>>14;var b=p*d+g*k;d=k*d+((b&16383)<<14)+r[e]+o;o=(d>>28)+(b>>14)+p*g;r[e++]=d&268435455}return o}if(j_lm&&(navigator.appName=="Microsoft Internet Explorer")){BigInteger.prototype.am=am2;dbits=30}else{if(j_lm&&(navigator.appName!="Netscape")){BigInteger.prototype.am=am1;dbits=26}else{BigInteger.prototype.am=am3;dbits=28}}BigInteger.prototype.DB=dbits;BigInteger.prototype.DM=((1<<dbits)-1);BigInteger.prototype.DV=(1<<dbits);var BI_FP=52;BigInteger.prototype.FV=Math.pow(2,BI_FP);BigInteger.prototype.F1=BI_FP-dbits;BigInteger.prototype.F2=2*dbits-BI_FP;var BI_RM="0123456789abcdefghijklmnopqrstuvwxyz";var BI_RC=new Array();var rr,vv;rr="0".charCodeAt(0);for(vv=0;vv<=9;++vv){BI_RC[rr++]=vv}rr="a".charCodeAt(0);for(vv=10;vv<36;++vv){BI_RC[rr++]=vv}rr="A".charCodeAt(0);for(vv=10;vv<36;++vv){BI_RC[rr++]=vv}function int2char(a){return BI_RM.charAt(a)}function intAt(b,a){var d=BI_RC[b.charCodeAt(a)];return(d==null)?-1:d}function bnpCopyTo(b){for(var a=this.t-1;a>=0;--a){b[a]=this[a]}b.t=this.t;b.s=this.s}function bnpFromInt(a){this.t=1;this.s=(a<0)?-1:0;if(a>0){this[0]=a}else{if(a<-1){this[0]=a+this.DV}else{this.t=0}}}function nbv(a){var b=nbi();b.fromInt(a);return b}function bnpFromString(h,c){var e;if(c==16){e=4}else{if(c==8){e=3}else{if(c==256){e=8}else{if(c==2){e=1}else{if(c==32){e=5}else{if(c==4){e=2}else{this.fromRadix(h,c);return}}}}}}this.t=0;this.s=0;var g=h.length,d=false,f=0;while(--g>=0){var a=(e==8)?h[g]&255:intAt(h,g);if(a<0){if(h.charAt(g)=="-"){d=true}continue}d=false;if(f==0){this[this.t++]=a}else{if(f+e>this.DB){this[this.t-1]|=(a&((1<<(this.DB-f))-1))<<f;this[this.t++]=(a>>(this.DB-f))}else{this[this.t-1]|=a<<f}}f+=e;if(f>=this.DB){f-=this.DB}}if(e==8&&(h[0]&128)!=0){this.s=-1;if(f>0){this[this.t-1]|=((1<<(this.DB-f))-1)<<f}}this.clamp();if(d){BigInteger.ZERO.subTo(this,this)}}function bnpClamp(){var a=this.s&this.DM;while(this.t>0&&this[this.t-1]==a){--this.t}}function bnToString(c){if(this.s<0){return"-"+this.negate().toString(c)}var e;if(c==16){e=4}else{if(c==8){e=3}else{if(c==2){e=1}else{if(c==32){e=5}else{if(c==4){e=2}else{return this.toRadix(c)}}}}}var g=(1<<e)-1,l,a=false,h="",f=this.t;var j=this.DB-(f*this.DB)%e;if(f-->0){if(j<this.DB&&(l=this[f]>>j)>0){a=true;h=int2char(l)}while(f>=0){if(j<e){l=(this[f]&((1<<j)-1))<<(e-j);l|=this[--f]>>(j+=this.DB-e)}else{l=(this[f]>>(j-=e))&g;if(j<=0){j+=this.DB;--f}}if(l>0){a=true}if(a){h+=int2char(l)}}}return a?h:"0"}function bnNegate(){var a=nbi();BigInteger.ZERO.subTo(this,a);return a}function bnAbs(){return(this.s<0)?this.negate():this}function bnCompareTo(b){var d=this.s-b.s;if(d!=0){return d}var c=this.t;d=c-b.t;if(d!=0){return(this.s<0)?-d:d}while(--c>=0){if((d=this[c]-b[c])!=0){return d}}return 0}function nbits(a){var c=1,b;if((b=a>>>16)!=0){a=b;c+=16}if((b=a>>8)!=0){a=b;c+=8}if((b=a>>4)!=0){a=b;c+=4}if((b=a>>2)!=0){a=b;c+=2}if((b=a>>1)!=0){a=b;c+=1}return c}function bnBitLength(){if(this.t<=0){return 0}return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM))}function bnpDLShiftTo(c,b){var a;for(a=this.t-1;a>=0;--a){b[a+c]=this[a]}for(a=c-1;a>=0;--a){b[a]=0}b.t=this.t+c;b.s=this.s}function bnpDRShiftTo(c,b){for(var a=c;a<this.t;++a){b[a-c]=this[a]}b.t=Math.max(this.t-c,0);b.s=this.s}function bnpLShiftTo(j,e){var b=j%this.DB;var a=this.DB-b;var g=(1<<a)-1;var f=Math.floor(j/this.DB),h=(this.s<<b)&this.DM,d;for(d=this.t-1;d>=0;--d){e[d+f+1]=(this[d]>>a)|h;h=(this[d]&g)<<b}for(d=f-1;d>=0;--d){e[d]=0}e[f]=h;e.t=this.t+f+1;e.s=this.s;e.clamp()}function bnpRShiftTo(g,d){d.s=this.s;var e=Math.floor(g/this.DB);if(e>=this.t){d.t=0;return}var b=g%this.DB;var a=this.DB-b;var f=(1<<b)-1;d[0]=this[e]>>b;for(var c=e+1;c<this.t;++c){d[c-e-1]|=(this[c]&f)<<a;d[c-e]=this[c]>>b}if(b>0){d[this.t-e-1]|=(this.s&f)<<a}d.t=this.t-e;d.clamp()}function bnpSubTo(d,f){var e=0,g=0,b=Math.min(d.t,this.t);while(e<b){g+=this[e]-d[e];f[e++]=g&this.DM;g>>=this.DB}if(d.t<this.t){g-=d.s;while(e<this.t){g+=this[e];f[e++]=g&this.DM;g>>=this.DB}g+=this.s}else{g+=this.s;while(e<d.t){g-=d[e];f[e++]=g&this.DM;g>>=this.DB}g-=d.s}f.s=(g<0)?-1:0;if(g<-1){f[e++]=this.DV+g}else{if(g>0){f[e++]=g}}f.t=e;f.clamp()}function bnpMultiplyTo(c,e){var b=this.abs(),f=c.abs();var d=b.t;e.t=d+f.t;while(--d>=0){e[d]=0}for(d=0;d<f.t;++d){e[d+b.t]=b.am(0,f[d],e,d,0,b.t)}e.s=0;e.clamp();if(this.s!=c.s){BigInteger.ZERO.subTo(e,e)}}function bnpSquareTo(d){var a=this.abs();var b=d.t=2*a.t;while(--b>=0){d[b]=0}for(b=0;b<a.t-1;++b){var e=a.am(b,a[b],d,2*b,0,1);if((d[b+a.t]+=a.am(b+1,2*a[b],d,2*b+1,e,a.t-b-1))>=a.DV){d[b+a.t]-=a.DV;d[b+a.t+1]=1}}if(d.t>0){d[d.t-1]+=a.am(b,a[b],d,2*b,0,1)}d.s=0;d.clamp()}function bnpDivRemTo(n,h,g){var w=n.abs();if(w.t<=0){return}var k=this.abs();if(k.t<w.t){if(h!=null){h.fromInt(0)}if(g!=null){this.copyTo(g)}return}if(g==null){g=nbi()}var d=nbi(),a=this.s,l=n.s;var v=this.DB-nbits(w[w.t-1]);if(v>0){w.lShiftTo(v,d);k.lShiftTo(v,g)}else{w.copyTo(d);k.copyTo(g)}var p=d.t;var b=d[p-1];if(b==0){return}var o=b*(1<<this.F1)+((p>1)?d[p-2]>>this.F2:0);var A=this.FV/o,z=(1<<this.F1)/o,x=1<<this.F2;var u=g.t,s=u-p,f=(h==null)?nbi():h;d.dlShiftTo(s,f);if(g.compareTo(f)>=0){g[g.t++]=1;g.subTo(f,g)}BigInteger.ONE.dlShiftTo(p,f);f.subTo(d,d);while(d.t<p){d[d.t++]=0}while(--s>=0){var c=(g[--u]==b)?this.DM:Math.floor(g[u]*A+(g[u-1]+x)*z);if((g[u]+=d.am(0,c,g,s,0,p))<c){d.dlShiftTo(s,f);g.subTo(f,g);while(g[u]<--c){g.subTo(f,g)}}}if(h!=null){g.drShiftTo(p,h);if(a!=l){BigInteger.ZERO.subTo(h,h)}}g.t=p;g.clamp();if(v>0){g.rShiftTo(v,g)}if(a<0){BigInteger.ZERO.subTo(g,g)}}function bnMod(b){var c=nbi();this.abs().divRemTo(b,null,c);if(this.s<0&&c.compareTo(BigInteger.ZERO)>0){b.subTo(c,c)}return c}function Classic(a){this.m=a}function cConvert(a){if(a.s<0||a.compareTo(this.m)>=0){return a.mod(this.m)}else{return a}}function cRevert(a){return a}function cReduce(a){a.divRemTo(this.m,null,a)}function cMulTo(a,c,b){a.multiplyTo(c,b);this.reduce(b)}function cSqrTo(a,b){a.squareTo(b);this.reduce(b)}Classic.prototype.convert=cConvert;Classic.prototype.revert=cRevert;Classic.prototype.reduce=cReduce;Classic.prototype.mulTo=cMulTo;Classic.prototype.sqrTo=cSqrTo;function bnpInvDigit(){if(this.t<1){return 0}var a=this[0];if((a&1)==0){return 0}var b=a&3;b=(b*(2-(a&15)*b))&15;b=(b*(2-(a&255)*b))&255;b=(b*(2-(((a&65535)*b)&65535)))&65535;b=(b*(2-a*b%this.DV))%this.DV;return(b>0)?this.DV-b:-b}function Montgomery(a){this.m=a;this.mp=a.invDigit();this.mpl=this.mp&32767;this.mph=this.mp>>15;this.um=(1<<(a.DB-15))-1;this.mt2=2*a.t}function montConvert(a){var b=nbi();a.abs().dlShiftTo(this.m.t,b);b.divRemTo(this.m,null,b);if(a.s<0&&b.compareTo(BigInteger.ZERO)>0){this.m.subTo(b,b)}return b}function montRevert(a){var b=nbi();a.copyTo(b);this.reduce(b);return b}function montReduce(a){while(a.t<=this.mt2){a[a.t++]=0}for(var c=0;c<this.m.t;++c){var b=a[c]&32767;var d=(b*this.mpl+(((b*this.mph+(a[c]>>15)*this.mpl)&this.um)<<15))&a.DM;b=c+this.m.t;a[b]+=this.m.am(0,d,a,c,0,this.m.t);while(a[b]>=a.DV){a[b]-=a.DV;a[++b]++}}a.clamp();a.drShiftTo(this.m.t,a);if(a.compareTo(this.m)>=0){a.subTo(this.m,a)}}function montSqrTo(a,b){a.squareTo(b);this.reduce(b)}function montMulTo(a,c,b){a.multiplyTo(c,b);this.reduce(b)}Montgomery.prototype.convert=montConvert;Montgomery.prototype.revert=montRevert;Montgomery.prototype.reduce=montReduce;Montgomery.prototype.mulTo=montMulTo;Montgomery.prototype.sqrTo=montSqrTo;function bnpIsEven(){return((this.t>0)?(this[0]&1):this.s)==0}function bnpExp(h,j){if(h>4294967295||h<1){return BigInteger.ONE}var f=nbi(),a=nbi(),d=j.convert(this),c=nbits(h)-1;d.copyTo(f);while(--c>=0){j.sqrTo(f,a);if((h&(1<<c))>0){j.mulTo(a,d,f)}else{var b=f;f=a;a=b}}return j.revert(f)}function bnModPowInt(b,a){var c;if(b<256||a.isEven()){c=new Classic(a)}else{c=new Montgomery(a)}return this.exp(b,c)}BigInteger.prototype.copyTo=bnpCopyTo;BigInteger.prototype.fromInt=bnpFromInt;BigInteger.prototype.fromString=bnpFromString;BigInteger.prototype.clamp=bnpClamp;BigInteger.prototype.dlShiftTo=bnpDLShiftTo;BigInteger.prototype.drShiftTo=bnpDRShiftTo;BigInteger.prototype.lShiftTo=bnpLShiftTo;BigInteger.prototype.rShiftTo=bnpRShiftTo;BigInteger.prototype.subTo=bnpSubTo;BigInteger.prototype.multiplyTo=bnpMultiplyTo;BigInteger.prototype.squareTo=bnpSquareTo;BigInteger.prototype.divRemTo=bnpDivRemTo;BigInteger.prototype.invDigit=bnpInvDigit;BigInteger.prototype.isEven=bnpIsEven;BigInteger.prototype.exp=bnpExp;BigInteger.prototype.toString=bnToString;BigInteger.prototype.negate=bnNegate;BigInteger.prototype.abs=bnAbs;BigInteger.prototype.compareTo=bnCompareTo;BigInteger.prototype.bitLength=bnBitLength;BigInteger.prototype.mod=bnMod;BigInteger.prototype.modPowInt=bnModPowInt;BigInteger.ZERO=nbv(0);BigInteger.ONE=nbv(1);

/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
function bnClone(){var a=nbi();this.copyTo(a);return a}function bnIntValue(){if(this.s<0){if(this.t==1){return this[0]-this.DV}else{if(this.t==0){return -1}}}else{if(this.t==1){return this[0]}else{if(this.t==0){return 0}}}return((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0]}function bnByteValue(){return(this.t==0)?this.s:(this[0]<<24)>>24}function bnShortValue(){return(this.t==0)?this.s:(this[0]<<16)>>16}function bnpChunkSize(a){return Math.floor(Math.LN2*this.DB/Math.log(a))}function bnSigNum(){if(this.s<0){return -1}else{if(this.t<=0||(this.t==1&&this[0]<=0)){return 0}else{return 1}}}function bnpToRadix(c){if(c==null){c=10}if(this.signum()==0||c<2||c>36){return"0"}var f=this.chunkSize(c);var e=Math.pow(c,f);var i=nbv(e),j=nbi(),h=nbi(),g="";this.divRemTo(i,j,h);while(j.signum()>0){g=(e+h.intValue()).toString(c).substr(1)+g;j.divRemTo(i,j,h)}return h.intValue().toString(c)+g}function bnpFromRadix(m,h){this.fromInt(0);if(h==null){h=10}var f=this.chunkSize(h);var g=Math.pow(h,f),e=false,a=0,l=0;for(var c=0;c<m.length;++c){var k=intAt(m,c);if(k<0){if(m.charAt(c)=="-"&&this.signum()==0){e=true}continue}l=h*l+k;if(++a>=f){this.dMultiply(g);this.dAddOffset(l,0);a=0;l=0}}if(a>0){this.dMultiply(Math.pow(h,a));this.dAddOffset(l,0)}if(e){BigInteger.ZERO.subTo(this,this)}}function bnpFromNumber(f,e,h){if("number"==typeof e){if(f<2){this.fromInt(1)}else{this.fromNumber(f,h);if(!this.testBit(f-1)){this.bitwiseTo(BigInteger.ONE.shiftLeft(f-1),op_or,this)}if(this.isEven()){this.dAddOffset(1,0)}while(!this.isProbablePrime(e)){this.dAddOffset(2,0);if(this.bitLength()>f){this.subTo(BigInteger.ONE.shiftLeft(f-1),this)}}}}else{var d=new Array(),g=f&7;d.length=(f>>3)+1;e.nextBytes(d);if(g>0){d[0]&=((1<<g)-1)}else{d[0]=0}this.fromString(d,256)}}function bnToByteArray(){var b=this.t,c=new Array();c[0]=this.s;var e=this.DB-(b*this.DB)%8,f,a=0;if(b-->0){if(e<this.DB&&(f=this[b]>>e)!=(this.s&this.DM)>>e){c[a++]=f|(this.s<<(this.DB-e))}while(b>=0){if(e<8){f=(this[b]&((1<<e)-1))<<(8-e);f|=this[--b]>>(e+=this.DB-8)}else{f=(this[b]>>(e-=8))&255;if(e<=0){e+=this.DB;--b}}if((f&128)!=0){f|=-256}if(a==0&&(this.s&128)!=(f&128)){++a}if(a>0||f!=this.s){c[a++]=f}}}return c}function bnEquals(b){return(this.compareTo(b)==0)}function bnMin(b){return(this.compareTo(b)<0)?this:b}function bnMax(b){return(this.compareTo(b)>0)?this:b}function bnpBitwiseTo(c,h,e){var d,g,b=Math.min(c.t,this.t);for(d=0;d<b;++d){e[d]=h(this[d],c[d])}if(c.t<this.t){g=c.s&this.DM;for(d=b;d<this.t;++d){e[d]=h(this[d],g)}e.t=this.t}else{g=this.s&this.DM;for(d=b;d<c.t;++d){e[d]=h(g,c[d])}e.t=c.t}e.s=h(this.s,c.s);e.clamp()}function op_and(a,b){return a&b}function bnAnd(b){var c=nbi();this.bitwiseTo(b,op_and,c);return c}function op_or(a,b){return a|b}function bnOr(b){var c=nbi();this.bitwiseTo(b,op_or,c);return c}function op_xor(a,b){return a^b}function bnXor(b){var c=nbi();this.bitwiseTo(b,op_xor,c);return c}function op_andnot(a,b){return a&~b}function bnAndNot(b){var c=nbi();this.bitwiseTo(b,op_andnot,c);return c}function bnNot(){var b=nbi();for(var a=0;a<this.t;++a){b[a]=this.DM&~this[a]}b.t=this.t;b.s=~this.s;return b}function bnShiftLeft(b){var a=nbi();if(b<0){this.rShiftTo(-b,a)}else{this.lShiftTo(b,a)}return a}function bnShiftRight(b){var a=nbi();if(b<0){this.lShiftTo(-b,a)}else{this.rShiftTo(b,a)}return a}function lbit(a){if(a==0){return -1}var b=0;if((a&65535)==0){a>>=16;b+=16}if((a&255)==0){a>>=8;b+=8}if((a&15)==0){a>>=4;b+=4}if((a&3)==0){a>>=2;b+=2}if((a&1)==0){++b}return b}function bnGetLowestSetBit(){for(var a=0;a<this.t;++a){if(this[a]!=0){return a*this.DB+lbit(this[a])}}if(this.s<0){return this.t*this.DB}return -1}function cbit(a){var b=0;while(a!=0){a&=a-1;++b}return b}function bnBitCount(){var c=0,a=this.s&this.DM;for(var b=0;b<this.t;++b){c+=cbit(this[b]^a)}return c}function bnTestBit(b){var a=Math.floor(b/this.DB);if(a>=this.t){return(this.s!=0)}return((this[a]&(1<<(b%this.DB)))!=0)}function bnpChangeBit(c,b){var a=BigInteger.ONE.shiftLeft(c);this.bitwiseTo(a,b,a);return a}function bnSetBit(a){return this.changeBit(a,op_or)}function bnClearBit(a){return this.changeBit(a,op_andnot)}function bnFlipBit(a){return this.changeBit(a,op_xor)}function bnpAddTo(d,f){var e=0,g=0,b=Math.min(d.t,this.t);while(e<b){g+=this[e]+d[e];f[e++]=g&this.DM;g>>=this.DB}if(d.t<this.t){g+=d.s;while(e<this.t){g+=this[e];f[e++]=g&this.DM;g>>=this.DB}g+=this.s}else{g+=this.s;while(e<d.t){g+=d[e];f[e++]=g&this.DM;g>>=this.DB}g+=d.s}f.s=(g<0)?-1:0;if(g>0){f[e++]=g}else{if(g<-1){f[e++]=this.DV+g}}f.t=e;f.clamp()}function bnAdd(b){var c=nbi();this.addTo(b,c);return c}function bnSubtract(b){var c=nbi();this.subTo(b,c);return c}function bnMultiply(b){var c=nbi();this.multiplyTo(b,c);return c}function bnSquare(){var a=nbi();this.squareTo(a);return a}function bnDivide(b){var c=nbi();this.divRemTo(b,c,null);return c}function bnRemainder(b){var c=nbi();this.divRemTo(b,null,c);return c}function bnDivideAndRemainder(b){var d=nbi(),c=nbi();this.divRemTo(b,d,c);return new Array(d,c)}function bnpDMultiply(a){this[this.t]=this.am(0,a-1,this,0,0,this.t);++this.t;this.clamp()}function bnpDAddOffset(b,a){if(b==0){return}while(this.t<=a){this[this.t++]=0}this[a]+=b;while(this[a]>=this.DV){this[a]-=this.DV;if(++a>=this.t){this[this.t++]=0}++this[a]}}function NullExp(){}function nNop(a){return a}function nMulTo(a,c,b){a.multiplyTo(c,b)}function nSqrTo(a,b){a.squareTo(b)}NullExp.prototype.convert=nNop;NullExp.prototype.revert=nNop;NullExp.prototype.mulTo=nMulTo;NullExp.prototype.sqrTo=nSqrTo;function bnPow(a){return this.exp(a,new NullExp())}function bnpMultiplyLowerTo(b,f,e){var d=Math.min(this.t+b.t,f);e.s=0;e.t=d;while(d>0){e[--d]=0}var c;for(c=e.t-this.t;d<c;++d){e[d+this.t]=this.am(0,b[d],e,d,0,this.t)}for(c=Math.min(b.t,f);d<c;++d){this.am(0,b[d],e,d,0,f-d)}e.clamp()}function bnpMultiplyUpperTo(b,e,d){--e;var c=d.t=this.t+b.t-e;d.s=0;while(--c>=0){d[c]=0}for(c=Math.max(e-this.t,0);c<b.t;++c){d[this.t+c-e]=this.am(e-c,b[c],d,0,0,this.t+c-e)}d.clamp();d.drShiftTo(1,d)}function Barrett(a){this.r2=nbi();this.q3=nbi();BigInteger.ONE.dlShiftTo(2*a.t,this.r2);this.mu=this.r2.divide(a);this.m=a}function barrettConvert(a){if(a.s<0||a.t>2*this.m.t){return a.mod(this.m)}else{if(a.compareTo(this.m)<0){return a}else{var b=nbi();a.copyTo(b);this.reduce(b);return b}}}function barrettRevert(a){return a}function barrettReduce(a){a.drShiftTo(this.m.t-1,this.r2);if(a.t>this.m.t+1){a.t=this.m.t+1;a.clamp()}this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);while(a.compareTo(this.r2)<0){a.dAddOffset(1,this.m.t+1)}a.subTo(this.r2,a);while(a.compareTo(this.m)>=0){a.subTo(this.m,a)}}function barrettSqrTo(a,b){a.squareTo(b);this.reduce(b)}function barrettMulTo(a,c,b){a.multiplyTo(c,b);this.reduce(b)}Barrett.prototype.convert=barrettConvert;Barrett.prototype.revert=barrettRevert;Barrett.prototype.reduce=barrettReduce;Barrett.prototype.mulTo=barrettMulTo;Barrett.prototype.sqrTo=barrettSqrTo;function bnModPow(q,f){var o=q.bitLength(),h,b=nbv(1),v;if(o<=0){return b}else{if(o<18){h=1}else{if(o<48){h=3}else{if(o<144){h=4}else{if(o<768){h=5}else{h=6}}}}}if(o<8){v=new Classic(f)}else{if(f.isEven()){v=new Barrett(f)}else{v=new Montgomery(f)}}var p=new Array(),d=3,s=h-1,a=(1<<h)-1;p[1]=v.convert(this);if(h>1){var A=nbi();v.sqrTo(p[1],A);while(d<=a){p[d]=nbi();v.mulTo(A,p[d-2],p[d]);d+=2}}var l=q.t-1,x,u=true,c=nbi(),y;o=nbits(q[l])-1;while(l>=0){if(o>=s){x=(q[l]>>(o-s))&a}else{x=(q[l]&((1<<(o+1))-1))<<(s-o);if(l>0){x|=q[l-1]>>(this.DB+o-s)}}d=h;while((x&1)==0){x>>=1;--d}if((o-=d)<0){o+=this.DB;--l}if(u){p[x].copyTo(b);u=false}else{while(d>1){v.sqrTo(b,c);v.sqrTo(c,b);d-=2}if(d>0){v.sqrTo(b,c)}else{y=b;b=c;c=y}v.mulTo(c,p[x],b)}while(l>=0&&(q[l]&(1<<o))==0){v.sqrTo(b,c);y=b;b=c;c=y;if(--o<0){o=this.DB-1;--l}}}return v.revert(b)}function bnGCD(c){var b=(this.s<0)?this.negate():this.clone();var h=(c.s<0)?c.negate():c.clone();if(b.compareTo(h)<0){var e=b;b=h;h=e}var d=b.getLowestSetBit(),f=h.getLowestSetBit();if(f<0){return b}if(d<f){f=d}if(f>0){b.rShiftTo(f,b);h.rShiftTo(f,h)}while(b.signum()>0){if((d=b.getLowestSetBit())>0){b.rShiftTo(d,b)}if((d=h.getLowestSetBit())>0){h.rShiftTo(d,h)}if(b.compareTo(h)>=0){b.subTo(h,b);b.rShiftTo(1,b)}else{h.subTo(b,h);h.rShiftTo(1,h)}}if(f>0){h.lShiftTo(f,h)}return h}function bnpModInt(e){if(e<=0){return 0}var c=this.DV%e,b=(this.s<0)?e-1:0;if(this.t>0){if(c==0){b=this[0]%e}else{for(var a=this.t-1;a>=0;--a){b=(c*b+this[a])%e}}}return b}function bnModInverse(f){var j=f.isEven();if((this.isEven()&&j)||f.signum()==0){return BigInteger.ZERO}var i=f.clone(),h=this.clone();var g=nbv(1),e=nbv(0),l=nbv(0),k=nbv(1);while(i.signum()!=0){while(i.isEven()){i.rShiftTo(1,i);if(j){if(!g.isEven()||!e.isEven()){g.addTo(this,g);e.subTo(f,e)}g.rShiftTo(1,g)}else{if(!e.isEven()){e.subTo(f,e)}}e.rShiftTo(1,e)}while(h.isEven()){h.rShiftTo(1,h);if(j){if(!l.isEven()||!k.isEven()){l.addTo(this,l);k.subTo(f,k)}l.rShiftTo(1,l)}else{if(!k.isEven()){k.subTo(f,k)}}k.rShiftTo(1,k)}if(i.compareTo(h)>=0){i.subTo(h,i);if(j){g.subTo(l,g)}e.subTo(k,e)}else{h.subTo(i,h);if(j){l.subTo(g,l)}k.subTo(e,k)}}if(h.compareTo(BigInteger.ONE)!=0){return BigInteger.ZERO}if(k.compareTo(f)>=0){return k.subtract(f)}if(k.signum()<0){k.addTo(f,k)}else{return k}if(k.signum()<0){return k.add(f)}else{return k}}var lowprimes=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];var lplim=(1<<26)/lowprimes[lowprimes.length-1];function bnIsProbablePrime(e){var d,b=this.abs();if(b.t==1&&b[0]<=lowprimes[lowprimes.length-1]){for(d=0;d<lowprimes.length;++d){if(b[0]==lowprimes[d]){return true}}return false}if(b.isEven()){return false}d=1;while(d<lowprimes.length){var a=lowprimes[d],c=d+1;while(c<lowprimes.length&&a<lplim){a*=lowprimes[c++]}a=b.modInt(a);while(d<c){if(a%lowprimes[d++]==0){return false}}}return b.millerRabin(e)}function bnpMillerRabin(f){var g=this.subtract(BigInteger.ONE);var c=g.getLowestSetBit();if(c<=0){return false}var h=g.shiftRight(c);f=(f+1)>>1;if(f>lowprimes.length){f=lowprimes.length}var b=nbi();for(var e=0;e<f;++e){b.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);var l=b.modPow(h,this);if(l.compareTo(BigInteger.ONE)!=0&&l.compareTo(g)!=0){var d=1;while(d++<c&&l.compareTo(g)!=0){l=l.modPowInt(2,this);if(l.compareTo(BigInteger.ONE)==0){return false}}if(l.compareTo(g)!=0){return false}}}return true}BigInteger.prototype.chunkSize=bnpChunkSize;BigInteger.prototype.toRadix=bnpToRadix;BigInteger.prototype.fromRadix=bnpFromRadix;BigInteger.prototype.fromNumber=bnpFromNumber;BigInteger.prototype.bitwiseTo=bnpBitwiseTo;BigInteger.prototype.changeBit=bnpChangeBit;BigInteger.prototype.addTo=bnpAddTo;BigInteger.prototype.dMultiply=bnpDMultiply;BigInteger.prototype.dAddOffset=bnpDAddOffset;BigInteger.prototype.multiplyLowerTo=bnpMultiplyLowerTo;BigInteger.prototype.multiplyUpperTo=bnpMultiplyUpperTo;BigInteger.prototype.modInt=bnpModInt;BigInteger.prototype.millerRabin=bnpMillerRabin;BigInteger.prototype.clone=bnClone;BigInteger.prototype.intValue=bnIntValue;BigInteger.prototype.byteValue=bnByteValue;BigInteger.prototype.shortValue=bnShortValue;BigInteger.prototype.signum=bnSigNum;BigInteger.prototype.toByteArray=bnToByteArray;BigInteger.prototype.equals=bnEquals;BigInteger.prototype.min=bnMin;BigInteger.prototype.max=bnMax;BigInteger.prototype.and=bnAnd;BigInteger.prototype.or=bnOr;BigInteger.prototype.xor=bnXor;BigInteger.prototype.andNot=bnAndNot;BigInteger.prototype.not=bnNot;BigInteger.prototype.shiftLeft=bnShiftLeft;BigInteger.prototype.shiftRight=bnShiftRight;BigInteger.prototype.getLowestSetBit=bnGetLowestSetBit;BigInteger.prototype.bitCount=bnBitCount;BigInteger.prototype.testBit=bnTestBit;BigInteger.prototype.setBit=bnSetBit;BigInteger.prototype.clearBit=bnClearBit;BigInteger.prototype.flipBit=bnFlipBit;BigInteger.prototype.add=bnAdd;BigInteger.prototype.subtract=bnSubtract;BigInteger.prototype.multiply=bnMultiply;BigInteger.prototype.divide=bnDivide;BigInteger.prototype.remainder=bnRemainder;BigInteger.prototype.divideAndRemainder=bnDivideAndRemainder;BigInteger.prototype.modPow=bnModPow;BigInteger.prototype.modInverse=bnModInverse;BigInteger.prototype.pow=bnPow;BigInteger.prototype.gcd=bnGCD;BigInteger.prototype.isProbablePrime=bnIsProbablePrime;BigInteger.prototype.square=bnSquare;

/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
function parseBigInt(b,a){return new BigInteger(b,a)}function linebrk(c,d){var a="";var b=0;while(b+d<c.length){a+=c.substring(b,b+d)+"\n";b+=d}return a+c.substring(b,c.length)}function byte2Hex(a){if(a<16){return"0"+a.toString(16)}else{return a.toString(16)}}function pkcs1pad2(e,h){if(h<e.length+11){alert("Message too long for RSA");return null}var g=new Array();var d=e.length-1;while(d>=0&&h>0){var f=e.charCodeAt(d--);if(f<128){g[--h]=f}else{if((f>127)&&(f<2048)){g[--h]=(f&63)|128;g[--h]=(f>>6)|192}else{g[--h]=(f&63)|128;g[--h]=((f>>6)&63)|128;g[--h]=(f>>12)|224}}}g[--h]=0;var b=new SecureRandom();var a=new Array();while(h>2){a[0]=0;while(a[0]==0){b.nextBytes(a)}g[--h]=a[0]}g[--h]=2;g[--h]=0;return new BigInteger(g)}function oaep_mgf1_arr(c,a,e){var b="",d=0;while(b.length<a){b+=e(String.fromCharCode.apply(String,c.concat([(d&4278190080)>>24,(d&16711680)>>16,(d&65280)>>8,d&255])));d+=1}return b}var SHA1_SIZE=20;function oaep_pad(l,a,c){if(l.length+2*SHA1_SIZE+2>a){throw"Message too long for RSA"}var h="",d;for(d=0;d<a-l.length-2*SHA1_SIZE-2;d+=1){h+="\x00"}var e=rstr_sha1("")+h+"\x01"+l;var f=new Array(SHA1_SIZE);new SecureRandom().nextBytes(f);var g=oaep_mgf1_arr(f,e.length,c||rstr_sha1);var k=[];for(d=0;d<e.length;d+=1){k[d]=e.charCodeAt(d)^g.charCodeAt(d)}var j=oaep_mgf1_arr(k,f.length,rstr_sha1);var b=[0];for(d=0;d<f.length;d+=1){b[d+1]=f[d]^j.charCodeAt(d)}return new BigInteger(b.concat(k))}function RSAKey(){this.n=null;this.e=0;this.d=null;this.p=null;this.q=null;this.dmp1=null;this.dmq1=null;this.coeff=null}function RSASetPublic(b,a){this.isPublic=true;if(typeof b!=="string"){this.n=b;this.e=a}else{if(b!=null&&a!=null&&b.length>0&&a.length>0){this.n=parseBigInt(b,16);this.e=parseInt(a,16)}else{alert("Invalid RSA public key")}}}function RSADoPublic(a){return a.modPowInt(this.e,this.n)}function RSAEncrypt(d){var a=pkcs1pad2(d,(this.n.bitLength()+7)>>3);if(a==null){return null}var e=this.doPublic(a);if(e==null){return null}var b=e.toString(16);if((b.length&1)==0){return b}else{return"0"+b}}function RSAEncryptOAEP(e,d){var a=oaep_pad(e,(this.n.bitLength()+7)>>3,d);if(a==null){return null}var f=this.doPublic(a);if(f==null){return null}var b=f.toString(16);if((b.length&1)==0){return b}else{return"0"+b}}RSAKey.prototype.doPublic=RSADoPublic;RSAKey.prototype.setPublic=RSASetPublic;RSAKey.prototype.encrypt=RSAEncrypt;RSAKey.prototype.encryptOAEP=RSAEncryptOAEP;RSAKey.prototype.type="RSA";

/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
function pkcs1unpad2(g,j){var a=g.toByteArray();var f=0;while(f<a.length&&a[f]==0){++f}if(a.length-f!=j-1||a[f]!=2){return null}++f;while(a[f]!=0){if(++f>=a.length){return null}}var e="";while(++f<a.length){var h=a[f]&255;if(h<128){e+=String.fromCharCode(h)}else{if((h>191)&&(h<224)){e+=String.fromCharCode(((h&31)<<6)|(a[f+1]&63));++f}else{e+=String.fromCharCode(((h&15)<<12)|((a[f+1]&63)<<6)|(a[f+2]&63));f+=2}}}return e}function oaep_mgf1_str(c,a,e){var b="",d=0;while(b.length<a){b+=e(c+String.fromCharCode.apply(String,[(d&4278190080)>>24,(d&16711680)>>16,(d&65280)>>8,d&255]));d+=1}return b}var SHA1_SIZE=20;function oaep_unpad(l,b,e){l=l.toByteArray();var f;for(f=0;f<l.length;f+=1){l[f]&=255}while(l.length<b){l.unshift(0)}l=String.fromCharCode.apply(String,l);if(l.length<2*SHA1_SIZE+2){throw"Cipher too short"}var c=l.substr(1,SHA1_SIZE);var o=l.substr(SHA1_SIZE+1);var m=oaep_mgf1_str(o,SHA1_SIZE,e||rstr_sha1);var h=[],f;for(f=0;f<c.length;f+=1){h[f]=c.charCodeAt(f)^m.charCodeAt(f)}var j=oaep_mgf1_str(String.fromCharCode.apply(String,h),l.length-SHA1_SIZE,rstr_sha1);var g=[];for(f=0;f<o.length;f+=1){g[f]=o.charCodeAt(f)^j.charCodeAt(f)}g=String.fromCharCode.apply(String,g);if(g.substr(0,SHA1_SIZE)!==rstr_sha1("")){throw"Hash mismatch"}g=g.substr(SHA1_SIZE);var a=g.indexOf("\x01");var k=(a!=-1)?g.substr(0,a).lastIndexOf("\x00"):-1;if(k+1!=a){throw"Malformed data"}return g.substr(a+1)}function RSASetPrivate(c,a,b){this.isPrivate=true;if(typeof c!=="string"){this.n=c;this.e=a;this.d=b}else{if(c!=null&&a!=null&&c.length>0&&a.length>0){this.n=parseBigInt(c,16);this.e=parseInt(a,16);this.d=parseBigInt(b,16)}else{alert("Invalid RSA private key")}}}function RSASetPrivateEx(g,d,e,c,b,a,h,f){this.isPrivate=true;if(g==null){throw"RSASetPrivateEx N == null"}if(d==null){throw"RSASetPrivateEx E == null"}if(g.length==0){throw"RSASetPrivateEx N.length == 0"}if(d.length==0){throw"RSASetPrivateEx E.length == 0"}if(g!=null&&d!=null&&g.length>0&&d.length>0){this.n=parseBigInt(g,16);this.e=parseInt(d,16);this.d=parseBigInt(e,16);this.p=parseBigInt(c,16);this.q=parseBigInt(b,16);this.dmp1=parseBigInt(a,16);this.dmq1=parseBigInt(h,16);this.coeff=parseBigInt(f,16)}else{alert("Invalid RSA private key in RSASetPrivateEx")}}function RSAGenerate(b,i){var a=new SecureRandom();var f=b>>1;this.e=parseInt(i,16);var c=new BigInteger(i,16);for(;;){for(;;){this.p=new BigInteger(b-f,1,a);if(this.p.subtract(BigInteger.ONE).gcd(c).compareTo(BigInteger.ONE)==0&&this.p.isProbablePrime(10)){break}}for(;;){this.q=new BigInteger(f,1,a);if(this.q.subtract(BigInteger.ONE).gcd(c).compareTo(BigInteger.ONE)==0&&this.q.isProbablePrime(10)){break}}if(this.p.compareTo(this.q)<=0){var h=this.p;this.p=this.q;this.q=h}var g=this.p.subtract(BigInteger.ONE);var d=this.q.subtract(BigInteger.ONE);var e=g.multiply(d);if(e.gcd(c).compareTo(BigInteger.ONE)==0){this.n=this.p.multiply(this.q);this.d=c.modInverse(e);this.dmp1=this.d.mod(g);this.dmq1=this.d.mod(d);this.coeff=this.q.modInverse(this.p);break}}}function RSADoPrivate(a){if(this.p==null||this.q==null){return a.modPow(this.d,this.n)}var c=a.mod(this.p).modPow(this.dmp1,this.p);var b=a.mod(this.q).modPow(this.dmq1,this.q);while(c.compareTo(b)<0){c=c.add(this.p)}return c.subtract(b).multiply(this.coeff).mod(this.p).multiply(this.q).add(b)}function RSADecrypt(b){var d=parseBigInt(b,16);var a=this.doPrivate(d);if(a==null){return null}return pkcs1unpad2(a,(this.n.bitLength()+7)>>3)}function RSADecryptOAEP(d,b){var e=parseBigInt(d,16);var a=this.doPrivate(e);if(a==null){return null}return oaep_unpad(a,(this.n.bitLength()+7)>>3,b)}RSAKey.prototype.doPrivate=RSADoPrivate;RSAKey.prototype.setPrivate=RSASetPrivate;RSAKey.prototype.setPrivateEx=RSASetPrivateEx;RSAKey.prototype.generate=RSAGenerate;RSAKey.prototype.decrypt=RSADecrypt;RSAKey.prototype.decryptOAEP=RSADecryptOAEP;

/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
var b64map="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";var b64pad="=";function hex2b64(d){var b;var e;var a="";for(b=0;b+3<=d.length;b+=3){e=parseInt(d.substring(b,b+3),16);a+=b64map.charAt(e>>6)+b64map.charAt(e&63)}if(b+1==d.length){e=parseInt(d.substring(b,b+1),16);a+=b64map.charAt(e<<2)}else{if(b+2==d.length){e=parseInt(d.substring(b,b+2),16);a+=b64map.charAt(e>>2)+b64map.charAt((e&3)<<4)}}if(b64pad){while((a.length&3)>0){a+=b64pad}}return a}function b64tohex(f){var d="";var e;var b=0;var c;var a;for(e=0;e<f.length;++e){if(f.charAt(e)==b64pad){break}a=b64map.indexOf(f.charAt(e));if(a<0){continue}if(b==0){d+=int2char(a>>2);c=a&3;b=1}else{if(b==1){d+=int2char((c<<2)|(a>>4));c=a&15;b=2}else{if(b==2){d+=int2char(c);d+=int2char(a>>2);c=a&3;b=3}else{d+=int2char((c<<2)|(a>>4));d+=int2char(a&15);b=0}}}}if(b==1){d+=int2char(c<<2)}return d}function b64toBA(e){var d=b64tohex(e);var c;var b=new Array();for(c=0;2*c<d.length;++c){b[c]=parseInt(d.substring(2*c,2*c+2),16)}return b};

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/**
 * CryptoJS core components.
 */
var CryptoJS = CryptoJS || (function (Math, undefined) {
    /**
     * CryptoJS namespace.
     */
    var C = {};

    /**
     * Library namespace.
     */
    var C_lib = C.lib = {};

    /**
     * Base object for prototypal inheritance.
     */
    var Base = C_lib.Base = (function () {
        function F() {}

        return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function (overrides) {
                // Spawn
                F.prototype = this;
                var subtype = new F();

                // Augment
                if (overrides) {
                    subtype.mixIn(overrides);
                }

                // Create default initializer
                if (!subtype.hasOwnProperty('init')) {
                    subtype.init = function () {
                        subtype.$super.init.apply(this, arguments);
                    };
                }

                // Initializer's prototype is the subtype object
                subtype.init.prototype = subtype;

                // Reference supertype
                subtype.$super = this;

                return subtype;
            },

            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function () {
                var instance = this.extend();
                instance.init.apply(instance, arguments);

                return instance;
            },

            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function () {
            },

            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function (properties) {
                for (var propertyName in properties) {
                    if (properties.hasOwnProperty(propertyName)) {
                        this[propertyName] = properties[propertyName];
                    }
                }

                // IE won't copy toString using the loop above
                if (properties.hasOwnProperty('toString')) {
                    this.toString = properties.toString;
                }
            },

            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function () {
                return this.init.prototype.extend(this);
            }
        };
    }());

    /**
     * An array of 32-bit words.
     *
     * @property {Array} words The array of 32-bit words.
     * @property {number} sigBytes The number of significant bytes in this word array.
     */
    var WordArray = C_lib.WordArray = Base.extend({
        /**
         * Initializes a newly created word array.
         *
         * @param {Array} words (Optional) An array of 32-bit words.
         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.create();
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
         */
        init: function (words, sigBytes) {
            words = this.words = words || [];

            if (sigBytes != undefined) {
                this.sigBytes = sigBytes;
            } else {
                this.sigBytes = words.length * 4;
            }
        },

        /**
         * Converts this word array to a string.
         *
         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
         *
         * @return {string} The stringified word array.
         *
         * @example
         *
         *     var string = wordArray + '';
         *     var string = wordArray.toString();
         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
         */
        toString: function (encoder) {
            return (encoder || Hex).stringify(this);
        },

        /**
         * Concatenates a word array to this word array.
         *
         * @param {WordArray} wordArray The word array to append.
         *
         * @return {WordArray} This word array.
         *
         * @example
         *
         *     wordArray1.concat(wordArray2);
         */
        concat: function (wordArray) {
            // Shortcuts
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;

            // Clamp excess bits
            this.clamp();

            // Concat
            if (thisSigBytes % 4) {
                // Copy one byte at a time
                for (var i = 0; i < thatSigBytes; i++) {
                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
                }
            } else if (thatWords.length > 0xffff) {
                // Copy one word at a time
                for (var i = 0; i < thatSigBytes; i += 4) {
                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
                }
            } else {
                // Copy all words at once
                thisWords.push.apply(thisWords, thatWords);
            }
            this.sigBytes += thatSigBytes;

            // Chainable
            return this;
        },

        /**
         * Removes insignificant bits.
         *
         * @example
         *
         *     wordArray.clamp();
         */
        clamp: function () {
            // Shortcuts
            var words = this.words;
            var sigBytes = this.sigBytes;

            // Clamp
            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
            words.length = Math.ceil(sigBytes / 4);
        },

        /**
         * Creates a copy of this word array.
         *
         * @return {WordArray} The clone.
         *
         * @example
         *
         *     var clone = wordArray.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);

            return clone;
        },

        /**
         * Creates a word array filled with random bytes.
         *
         * @param {number} nBytes The number of random bytes to generate.
         *
         * @return {WordArray} The random word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.random(16);
         */
        random: function (nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
                words.push((Math.random() * 0x100000000) | 0);
            }

            return new WordArray.init(words, nBytes);
        }
    });

    /**
     * Encoder namespace.
     */
    var C_enc = C.enc = {};

    /**
     * Hex encoding strategy.
     */
    var Hex = C_enc.Hex = {
        /**
         * Converts a word array to a hex string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The hex string.
         *
         * @static
         *
         * @example
         *
         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;

            // Convert
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                hexChars.push((bite >>> 4).toString(16));
                hexChars.push((bite & 0x0f).toString(16));
            }

            return hexChars.join('');
        },

        /**
         * Converts a hex string to a word array.
         *
         * @param {string} hexStr The hex string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
         */
        parse: function (hexStr) {
            // Shortcut
            var hexStrLength = hexStr.length;

            // Convert
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
            }

            return new WordArray.init(words, hexStrLength / 2);
        }
    };

    /**
     * Latin1 encoding strategy.
     */
    var Latin1 = C_enc.Latin1 = {
        /**
         * Converts a word array to a Latin1 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Latin1 string.
         *
         * @static
         *
         * @example
         *
         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;

            // Convert
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                latin1Chars.push(String.fromCharCode(bite));
            }

            return latin1Chars.join('');
        },

        /**
         * Converts a Latin1 string to a word array.
         *
         * @param {string} latin1Str The Latin1 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
         */
        parse: function (latin1Str) {
            // Shortcut
            var latin1StrLength = latin1Str.length;

            // Convert
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
            }

            return new WordArray.init(words, latin1StrLength);
        }
    };

    /**
     * UTF-8 encoding strategy.
     */
    var Utf8 = C_enc.Utf8 = {
        /**
         * Converts a word array to a UTF-8 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The UTF-8 string.
         *
         * @static
         *
         * @example
         *
         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
         */
        stringify: function (wordArray) {
            try {
                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
                throw new Error('Malformed UTF-8 data');
            }
        },

        /**
         * Converts a UTF-8 string to a word array.
         *
         * @param {string} utf8Str The UTF-8 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
         */
        parse: function (utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
        }
    };

    /**
     * Abstract buffered block algorithm template.
     *
     * The property blockSize must be implemented in a concrete subtype.
     *
     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
     */
    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
        /**
         * Resets this block algorithm's data buffer to its initial state.
         *
         * @example
         *
         *     bufferedBlockAlgorithm.reset();
         */
        reset: function () {
            // Initial values
            this._data = new WordArray.init();
            this._nDataBytes = 0;
        },

        /**
         * Adds new data to this block algorithm's buffer.
         *
         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
         *
         * @example
         *
         *     bufferedBlockAlgorithm._append('data');
         *     bufferedBlockAlgorithm._append(wordArray);
         */
        _append: function (data) {
            // Convert string to WordArray, else assume WordArray already
            if (typeof data == 'string') {
                data = Utf8.parse(data);
            }

            // Append
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
        },

        /**
         * Processes available data blocks.
         *
         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
         *
         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
         *
         * @return {WordArray} The processed data.
         *
         * @example
         *
         *     var processedData = bufferedBlockAlgorithm._process();
         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
         */
        _process: function (doFlush) {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;

            // Count blocks ready
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
                // Round up to include partial blocks
                nBlocksReady = Math.ceil(nBlocksReady);
            } else {
                // Round down to include only full blocks,
                // less the number of blocks that must remain in the buffer
                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }

            // Count words ready
            var nWordsReady = nBlocksReady * blockSize;

            // Count bytes ready
            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

            // Process blocks
            if (nWordsReady) {
                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                    // Perform concrete-algorithm logic
                    this._doProcessBlock(dataWords, offset);
                }

                // Remove processed words
                var processedWords = dataWords.splice(0, nWordsReady);
                data.sigBytes -= nBytesReady;
            }

            // Return processed words
            return new WordArray.init(processedWords, nBytesReady);
        },

        /**
         * Creates a copy of this object.
         *
         * @return {Object} The clone.
         *
         * @example
         *
         *     var clone = bufferedBlockAlgorithm.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();

            return clone;
        },

        _minBufferSize: 0
    });

    /**
     * Abstract hasher template.
     *
     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
     */
    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
        /**
         * Configuration options.
         */
        cfg: Base.extend(),

        /**
         * Initializes a newly created hasher.
         *
         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
         *
         * @example
         *
         *     var hasher = CryptoJS.algo.SHA256.create();
         */
        init: function (cfg) {
            // Apply config defaults
            this.cfg = this.cfg.extend(cfg);

            // Set initial values
            this.reset();
        },

        /**
         * Resets this hasher to its initial state.
         *
         * @example
         *
         *     hasher.reset();
         */
        reset: function () {
            // Reset data buffer
            BufferedBlockAlgorithm.reset.call(this);

            // Perform concrete-hasher logic
            this._doReset();
        },

        /**
         * Updates this hasher with a message.
         *
         * @param {WordArray|string} messageUpdate The message to append.
         *
         * @return {Hasher} This hasher.
         *
         * @example
         *
         *     hasher.update('message');
         *     hasher.update(wordArray);
         */
        update: function (messageUpdate) {
            // Append
            this._append(messageUpdate);

            // Update the hash
            this._process();

            // Chainable
            return this;
        },

        /**
         * Finalizes the hash computation.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} messageUpdate (Optional) A final message update.
         *
         * @return {WordArray} The hash.
         *
         * @example
         *
         *     var hash = hasher.finalize();
         *     var hash = hasher.finalize('message');
         *     var hash = hasher.finalize(wordArray);
         */
        finalize: function (messageUpdate) {
            // Final message update
            if (messageUpdate) {
                this._append(messageUpdate);
            }

            // Perform concrete-hasher logic
            var hash = this._doFinalize();

            return hash;
        },

        blockSize: 512/32,

        /**
         * Creates a shortcut function to a hasher's object interface.
         *
         * @param {Hasher} hasher The hasher to create a helper for.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
         */
        _createHelper: function (hasher) {
            return function (message, cfg) {
                return new hasher.init(cfg).finalize(message);
            };
        },

        /**
         * Creates a shortcut function to the HMAC's object interface.
         *
         * @param {Hasher} hasher The hasher to use in this HMAC helper.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
         */
        _createHmacHelper: function (hasher) {
            return function (message, key) {
                return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
        }
    });

    /**
     * Algorithm namespace.
     */
    var C_algo = C.algo = {};

    return C;
}(Math));

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo;

    // Reusable object
    var W = [];

    /**
     * SHA-1 hash algorithm.
     */
    var SHA1 = C_algo.SHA1 = Hasher.extend({
        _doReset: function () {
            this._hash = new WordArray.init([
                0x67452301, 0xefcdab89,
                0x98badcfe, 0x10325476,
                0xc3d2e1f0
            ]);
        },

        _doProcessBlock: function (M, offset) {
            // Shortcut
            var H = this._hash.words;

            // Working variables
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];

            // Computation
            for (var i = 0; i < 80; i++) {
                if (i < 16) {
                    W[i] = M[offset + i] | 0;
                } else {
                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                    W[i] = (n << 1) | (n >>> 31);
                }

                var t = ((a << 5) | (a >>> 27)) + e + W[i];
                if (i < 20) {
                    t += ((b & c) | (~b & d)) + 0x5a827999;
                } else if (i < 40) {
                    t += (b ^ c ^ d) + 0x6ed9eba1;
                } else if (i < 60) {
                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
                } else /* if (i < 80) */ {
                    t += (b ^ c ^ d) - 0x359d3e2a;
                }

                e = d;
                d = c;
                c = (b << 30) | (b >>> 2);
                b = a;
                a = t;
            }

            // Intermediate hash value
            H[0] = (H[0] + a) | 0;
            H[1] = (H[1] + b) | 0;
            H[2] = (H[2] + c) | 0;
            H[3] = (H[3] + d) | 0;
            H[4] = (H[4] + e) | 0;
        },

        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;

            // Hash final blocks
            this._process();

            // Return final computed hash
            return this._hash;
        },

        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();

            return clone;
        }
    });

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA1('message');
     *     var hash = CryptoJS.SHA1(wordArray);
     */
    C.SHA1 = Hasher._createHelper(SHA1);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacSHA1(message, key);
     */
    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
}());

/*! rsapem-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
function _rsapem_pemToBase64(b){var a=b;a=a.replace("-----BEGIN RSA PRIVATE KEY-----","");a=a.replace("-----END RSA PRIVATE KEY-----","");a=a.replace(/[ \n]+/g,"");return a}function _rsapem_getPosArrayOfChildrenFromHex(d){var j=new Array();var k=ASN1HEX.getStartPosOfV_AtObj(d,0);var f=ASN1HEX.getPosOfNextSibling_AtObj(d,k);var h=ASN1HEX.getPosOfNextSibling_AtObj(d,f);var b=ASN1HEX.getPosOfNextSibling_AtObj(d,h);var l=ASN1HEX.getPosOfNextSibling_AtObj(d,b);var e=ASN1HEX.getPosOfNextSibling_AtObj(d,l);var g=ASN1HEX.getPosOfNextSibling_AtObj(d,e);var c=ASN1HEX.getPosOfNextSibling_AtObj(d,g);var i=ASN1HEX.getPosOfNextSibling_AtObj(d,c);j.push(k,f,h,b,l,e,g,c,i);return j}function _rsapem_getHexValueArrayOfChildrenFromHex(i){var o=_rsapem_getPosArrayOfChildrenFromHex(i);var r=ASN1HEX.getHexOfV_AtObj(i,o[0]);var f=ASN1HEX.getHexOfV_AtObj(i,o[1]);var j=ASN1HEX.getHexOfV_AtObj(i,o[2]);var k=ASN1HEX.getHexOfV_AtObj(i,o[3]);var c=ASN1HEX.getHexOfV_AtObj(i,o[4]);var b=ASN1HEX.getHexOfV_AtObj(i,o[5]);var h=ASN1HEX.getHexOfV_AtObj(i,o[6]);var g=ASN1HEX.getHexOfV_AtObj(i,o[7]);var l=ASN1HEX.getHexOfV_AtObj(i,o[8]);var m=new Array();m.push(r,f,j,k,c,b,h,g,l);return m}function _rsapem_readPrivateKeyFromASN1HexString(c){var b=_rsapem_getHexValueArrayOfChildrenFromHex(c);this.setPrivateEx(b[1],b[2],b[3],b[4],b[5],b[6],b[7],b[8])}function _rsapem_readPrivateKeyFromPEMString(e){var c=_rsapem_pemToBase64(e);var d=b64tohex(c);var b=_rsapem_getHexValueArrayOfChildrenFromHex(d);this.setPrivateEx(b[1],b[2],b[3],b[4],b[5],b[6],b[7],b[8])}RSAKey.prototype.readPrivateKeyFromPEMString=_rsapem_readPrivateKeyFromPEMString;RSAKey.prototype.readPrivateKeyFromASN1HexString=_rsapem_readPrivateKeyFromASN1HexString;

/*! rsasign-1.2.7.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
var _RE_HEXDECONLY=new RegExp("");_RE_HEXDECONLY.compile("[^0-9a-f]","gi");function _rsasign_getHexPaddedDigestInfoForString(d,e,a){var b=function(f){return KJUR.crypto.Util.hashString(f,a)};var c=b(d);return KJUR.crypto.Util.getPaddedDigestInfoHex(c,a,e)}function _zeroPaddingOfSignature(e,d){var c="";var a=d/4-e.length;for(var b=0;b<a;b++){c=c+"0"}return c+e}function _rsasign_signString(d,a){var b=function(e){return KJUR.crypto.Util.hashString(e,a)};var c=b(d);return this.signWithMessageHash(c,a)}function _rsasign_signWithMessageHash(e,c){var f=KJUR.crypto.Util.getPaddedDigestInfoHex(e,c,this.n.bitLength());var b=parseBigInt(f,16);var d=this.doPrivate(b);var a=d.toString(16);return _zeroPaddingOfSignature(a,this.n.bitLength())}function _rsasign_signStringWithSHA1(a){return _rsasign_signString.call(this,a,"sha1")}function _rsasign_signStringWithSHA256(a){return _rsasign_signString.call(this,a,"sha256")}function pss_mgf1_str(c,a,e){var b="",d=0;while(b.length<a){b+=hextorstr(e(rstrtohex(c+String.fromCharCode.apply(String,[(d&4278190080)>>24,(d&16711680)>>16,(d&65280)>>8,d&255]))));d+=1}return b}function _rsasign_signStringPSS(e,a,d){var c=function(f){return KJUR.crypto.Util.hashHex(f,a)};var b=c(rstrtohex(e));if(d===undefined){d=-1}return this.signWithMessageHashPSS(b,a,d)}function _rsasign_signWithMessageHashPSS(l,a,k){var b=hextorstr(l);var g=b.length;var m=this.n.bitLength()-1;var c=Math.ceil(m/8);var d;var o=function(i){return KJUR.crypto.Util.hashHex(i,a)};if(k===-1||k===undefined){k=g}else{if(k===-2){k=c-g-2}else{if(k<-2){throw"invalid salt length"}}}if(c<(g+k+2)){throw"data too long"}var f="";if(k>0){f=new Array(k);new SecureRandom().nextBytes(f);f=String.fromCharCode.apply(String,f)}var n=hextorstr(o(rstrtohex("\x00\x00\x00\x00\x00\x00\x00\x00"+b+f)));var j=[];for(d=0;d<c-k-g-2;d+=1){j[d]=0}var e=String.fromCharCode.apply(String,j)+"\x01"+f;var h=pss_mgf1_str(n,e.length,o);var q=[];for(d=0;d<e.length;d+=1){q[d]=e.charCodeAt(d)^h.charCodeAt(d)}var p=(65280>>(8*c-m))&255;q[0]&=~p;for(d=0;d<g;d++){q.push(n.charCodeAt(d))}q.push(188);return _zeroPaddingOfSignature(this.doPrivate(new BigInteger(q)).toString(16),this.n.bitLength())}function _rsasign_getDecryptSignatureBI(a,d,c){var b=new RSAKey();b.setPublic(d,c);var e=b.doPublic(a);return e}function _rsasign_getHexDigestInfoFromSig(a,c,b){var e=_rsasign_getDecryptSignatureBI(a,c,b);var d=e.toString(16).replace(/^1f+00/,"");return d}function _rsasign_getAlgNameAndHashFromHexDisgestInfo(f){for(var e in KJUR.crypto.Util.DIGESTINFOHEAD){var d=KJUR.crypto.Util.DIGESTINFOHEAD[e];var b=d.length;if(f.substring(0,b)==d){var c=[e,f.substring(b)];return c}}return[]}function _rsasign_verifySignatureWithArgs(f,b,g,j){var e=_rsasign_getHexDigestInfoFromSig(b,g,j);var h=_rsasign_getAlgNameAndHashFromHexDisgestInfo(e);if(h.length==0){return false}var d=h[0];var i=h[1];var a=function(k){return KJUR.crypto.Util.hashString(k,d)};var c=a(f);return(i==c)}function _rsasign_verifyHexSignatureForMessage(c,b){var d=parseBigInt(c,16);var a=_rsasign_verifySignatureWithArgs(b,d,this.n.toString(16),this.e.toString(16));return a}function _rsasign_verifyString(f,j){j=j.replace(_RE_HEXDECONLY,"");j=j.replace(/[ \n]+/g,"");var b=parseBigInt(j,16);if(b.bitLength()>this.n.bitLength()){return 0}var i=this.doPublic(b);var e=i.toString(16).replace(/^1f+00/,"");var g=_rsasign_getAlgNameAndHashFromHexDisgestInfo(e);if(g.length==0){return false}var d=g[0];var h=g[1];var a=function(k){return KJUR.crypto.Util.hashString(k,d)};var c=a(f);return(h==c)}function _rsasign_verifyWithMessageHash(e,a){a=a.replace(_RE_HEXDECONLY,"");a=a.replace(/[ \n]+/g,"");var b=parseBigInt(a,16);if(b.bitLength()>this.n.bitLength()){return 0}var h=this.doPublic(b);var g=h.toString(16).replace(/^1f+00/,"");var c=_rsasign_getAlgNameAndHashFromHexDisgestInfo(g);if(c.length==0){return false}var d=c[0];var f=c[1];return(f==e)}function _rsasign_verifyStringPSS(c,b,a,f){var e=function(g){return KJUR.crypto.Util.hashHex(g,a)};var d=e(rstrtohex(c));if(f===undefined){f=-1}return this.verifyWithMessageHashPSS(d,b,a,f)}function _rsasign_verifyWithMessageHashPSS(f,s,l,c){var k=new BigInteger(s,16);if(k.bitLength()>this.n.bitLength()){return false}var r=function(i){return KJUR.crypto.Util.hashHex(i,l)};var j=hextorstr(f);var h=j.length;var g=this.n.bitLength()-1;var m=Math.ceil(g/8);var q;if(c===-1||c===undefined){c=h}else{if(c===-2){c=m-h-2}else{if(c<-2){throw"invalid salt length"}}}if(m<(h+c+2)){throw"data too long"}var a=this.doPublic(k).toByteArray();for(q=0;q<a.length;q+=1){a[q]&=255}while(a.length<m){a.unshift(0)}if(a[m-1]!==188){throw"encoded message does not end in 0xbc"}a=String.fromCharCode.apply(String,a);var d=a.substr(0,m-h-1);var e=a.substr(d.length,h);var p=(65280>>(8*m-g))&255;if((d.charCodeAt(0)&p)!==0){throw"bits beyond keysize not zero"}var n=pss_mgf1_str(e,d.length,r);var o=[];for(q=0;q<d.length;q+=1){o[q]=d.charCodeAt(q)^n.charCodeAt(q)}o[0]&=~p;var b=m-h-c-2;for(q=0;q<b;q+=1){if(o[q]!==0){throw"leftmost octets not zero"}}if(o[b]!==1){throw"0x01 marker not found"}return e===hextorstr(r(rstrtohex("\x00\x00\x00\x00\x00\x00\x00\x00"+j+String.fromCharCode.apply(String,o.slice(-c)))))}RSAKey.prototype.signWithMessageHash=_rsasign_signWithMessageHash;RSAKey.prototype.signString=_rsasign_signString;RSAKey.prototype.signStringWithSHA1=_rsasign_signStringWithSHA1;RSAKey.prototype.signStringWithSHA256=_rsasign_signStringWithSHA256;RSAKey.prototype.sign=_rsasign_signString;RSAKey.prototype.signWithSHA1=_rsasign_signStringWithSHA1;RSAKey.prototype.signWithSHA256=_rsasign_signStringWithSHA256;RSAKey.prototype.signWithMessageHashPSS=_rsasign_signWithMessageHashPSS;RSAKey.prototype.signStringPSS=_rsasign_signStringPSS;RSAKey.prototype.signPSS=_rsasign_signStringPSS;RSAKey.SALT_LEN_HLEN=-1;RSAKey.SALT_LEN_MAX=-2;RSAKey.prototype.verifyWithMessageHash=_rsasign_verifyWithMessageHash;RSAKey.prototype.verifyString=_rsasign_verifyString;RSAKey.prototype.verifyHexSignatureForMessage=_rsasign_verifyHexSignatureForMessage;RSAKey.prototype.verify=_rsasign_verifyString;RSAKey.prototype.verifyHexSignatureForByteArrayMessage=_rsasign_verifyHexSignatureForMessage;RSAKey.prototype.verifyWithMessageHashPSS=_rsasign_verifyWithMessageHashPSS;RSAKey.prototype.verifyStringPSS=_rsasign_verifyStringPSS;RSAKey.prototype.verifyPSS=_rsasign_verifyStringPSS;RSAKey.SALT_LEN_RECOVER=-2;

/*! asn1hex-1.1.4.js (c) 2012-2013 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
var ASN1HEX=new function(){this.getByteLengthOfL_AtObj=function(b,c){if(b.substring(c+2,c+3)!="8"){return 1}var a=parseInt(b.substring(c+3,c+4));if(a==0){return -1}if(0<a&&a<10){return a+1}return -2};this.getHexOfL_AtObj=function(b,c){var a=this.getByteLengthOfL_AtObj(b,c);if(a<1){return""}return b.substring(c+2,c+2+a*2)};this.getIntOfL_AtObj=function(c,d){var b=this.getHexOfL_AtObj(c,d);if(b==""){return -1}var a;if(parseInt(b.substring(0,1))<8){a=new BigInteger(b,16)}else{a=new BigInteger(b.substring(2),16)}return a.intValue()};this.getStartPosOfV_AtObj=function(b,c){var a=this.getByteLengthOfL_AtObj(b,c);if(a<0){return a}return c+(a+1)*2};this.getHexOfV_AtObj=function(c,d){var b=this.getStartPosOfV_AtObj(c,d);var a=this.getIntOfL_AtObj(c,d);return c.substring(b,b+a*2)};this.getHexOfTLV_AtObj=function(c,e){var b=c.substr(e,2);var d=this.getHexOfL_AtObj(c,e);var a=this.getHexOfV_AtObj(c,e);return b+d+a};this.getPosOfNextSibling_AtObj=function(c,d){var b=this.getStartPosOfV_AtObj(c,d);var a=this.getIntOfL_AtObj(c,d);return b+a*2};this.getPosArrayOfChildren_AtObj=function(f,j){var c=new Array();var i=this.getStartPosOfV_AtObj(f,j);c.push(i);var b=this.getIntOfL_AtObj(f,j);var g=i;var d=0;while(1){var e=this.getPosOfNextSibling_AtObj(f,g);if(e==null||(e-i>=(b*2))){break}if(d>=200){break}c.push(e);g=e;d++}return c};this.getNthChildIndex_AtObj=function(d,b,e){var c=this.getPosArrayOfChildren_AtObj(d,b);return c[e]};this.getDecendantIndexByNthList=function(e,d,c){if(c.length==0){return d}var f=c.shift();var b=this.getPosArrayOfChildren_AtObj(e,d);return this.getDecendantIndexByNthList(e,b[f],c)};this.getDecendantHexTLVByNthList=function(d,c,b){var a=this.getDecendantIndexByNthList(d,c,b);return this.getHexOfTLV_AtObj(d,a)};this.getDecendantHexVByNthList=function(d,c,b){var a=this.getDecendantIndexByNthList(d,c,b);return this.getHexOfV_AtObj(d,a)}};ASN1HEX.getVbyList=function(d,c,b,e){var a=this.getDecendantIndexByNthList(d,c,b);if(a===undefined){throw"can't find nthList object"}if(e!==undefined){if(d.substr(a,2)!=e){throw"checking tag doesn't match: "+d.substr(a,2)+"!="+e}}return this.getHexOfV_AtObj(d,a)};

/*! x509-1.1.2.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
function X509(){this.subjectPublicKeyRSA=null;this.subjectPublicKeyRSA_hN=null;this.subjectPublicKeyRSA_hE=null;this.hex=null;this.getSerialNumberHex=function(){return ASN1HEX.getDecendantHexVByNthList(this.hex,0,[0,1])};this.getIssuerHex=function(){return ASN1HEX.getDecendantHexTLVByNthList(this.hex,0,[0,3])};this.getIssuerString=function(){return X509.hex2dn(ASN1HEX.getDecendantHexTLVByNthList(this.hex,0,[0,3]))};this.getSubjectHex=function(){return ASN1HEX.getDecendantHexTLVByNthList(this.hex,0,[0,5])};this.getSubjectString=function(){return X509.hex2dn(ASN1HEX.getDecendantHexTLVByNthList(this.hex,0,[0,5]))};this.getNotBefore=function(){var a=ASN1HEX.getDecendantHexVByNthList(this.hex,0,[0,4,0]);a=a.replace(/(..)/g,"%$1");a=decodeURIComponent(a);return a};this.getNotAfter=function(){var a=ASN1HEX.getDecendantHexVByNthList(this.hex,0,[0,4,1]);a=a.replace(/(..)/g,"%$1");a=decodeURIComponent(a);return a};this.readCertPEM=function(c){var e=X509.pemToHex(c);var b=X509.getPublicKeyHexArrayFromCertHex(e);var d=new RSAKey();d.setPublic(b[0],b[1]);this.subjectPublicKeyRSA=d;this.subjectPublicKeyRSA_hN=b[0];this.subjectPublicKeyRSA_hE=b[1];this.hex=e};this.readCertPEMWithoutRSAInit=function(c){var d=X509.pemToHex(c);var b=X509.getPublicKeyHexArrayFromCertHex(d);this.subjectPublicKeyRSA.setPublic(b[0],b[1]);this.subjectPublicKeyRSA_hN=b[0];this.subjectPublicKeyRSA_hE=b[1];this.hex=d}}X509.pemToBase64=function(a){var b=a;b=b.replace("-----BEGIN CERTIFICATE-----","");b=b.replace("-----END CERTIFICATE-----","");b=b.replace(/[ \n]+/g,"");return b};X509.pemToHex=function(a){var c=X509.pemToBase64(a);var b=b64tohex(c);return b};X509.getSubjectPublicKeyPosFromCertHex=function(f){var e=X509.getSubjectPublicKeyInfoPosFromCertHex(f);if(e==-1){return -1}var b=ASN1HEX.getPosArrayOfChildren_AtObj(f,e);if(b.length!=2){return -1}var d=b[1];if(f.substring(d,d+2)!="03"){return -1}var c=ASN1HEX.getStartPosOfV_AtObj(f,d);if(f.substring(c,c+2)!="00"){return -1}return c+2};X509.getSubjectPublicKeyInfoPosFromCertHex=function(d){var c=ASN1HEX.getStartPosOfV_AtObj(d,0);var b=ASN1HEX.getPosArrayOfChildren_AtObj(d,c);if(b.length<1){return -1}if(d.substring(b[0],b[0]+10)=="a003020102"){if(b.length<6){return -1}return b[6]}else{if(b.length<5){return -1}return b[5]}};X509.getPublicKeyHexArrayFromCertHex=function(f){var e=X509.getSubjectPublicKeyPosFromCertHex(f);var b=ASN1HEX.getPosArrayOfChildren_AtObj(f,e);if(b.length!=2){return[]}var d=ASN1HEX.getHexOfV_AtObj(f,b[0]);var c=ASN1HEX.getHexOfV_AtObj(f,b[1]);if(d!=null&&c!=null){return[d,c]}else{return[]}};X509.getHexTbsCertificateFromCert=function(b){var a=ASN1HEX.getStartPosOfV_AtObj(b,0);return a};X509.getPublicKeyHexArrayFromCertPEM=function(c){var d=X509.pemToHex(c);var b=X509.getPublicKeyHexArrayFromCertHex(d);return b};X509.hex2dn=function(e){var f="";var c=ASN1HEX.getPosArrayOfChildren_AtObj(e,0);for(var d=0;d<c.length;d++){var b=ASN1HEX.getHexOfTLV_AtObj(e,c[d]);f=f+"/"+X509.hex2rdn(b)}return f};X509.hex2rdn=function(a){var f=ASN1HEX.getDecendantHexTLVByNthList(a,0,[0,0]);var e=ASN1HEX.getDecendantHexVByNthList(a,0,[0,1]);var c="";try{c=X509.DN_ATTRHEX[f]}catch(b){c=f}e=e.replace(/(..)/g,"%$1");var d=decodeURIComponent(e);return c+"="+d};X509.DN_ATTRHEX={"0603550406":"C","060355040a":"O","060355040b":"OU","0603550403":"CN","0603550405":"SN","0603550408":"ST","0603550407":"L",};X509.getPublicKeyFromCertPEM=function(f){var c=X509.getPublicKeyInfoPropOfCertPEM(f);if(c.algoid=="2a864886f70d010101"){var i=KEYUTIL.parsePublicRawRSAKeyHex(c.keyhex);var j=new RSAKey();j.setPublic(i.n,i.e);return j}else{if(c.algoid=="2a8648ce3d0201"){var e=KJUR.crypto.OID.oidhex2name[c.algparam];var j=new KJUR.crypto.ECDSA({curve:e,info:c.keyhex});j.setPublicKeyHex(c.keyhex);return j}else{if(c.algoid=="2a8648ce380401"){var b=ASN1HEX.getVbyList(c.algparam,0,[0],"02");var a=ASN1HEX.getVbyList(c.algparam,0,[1],"02");var d=ASN1HEX.getVbyList(c.algparam,0,[2],"02");var h=ASN1HEX.getHexOfV_AtObj(c.keyhex,0);h=h.substr(2);var j=new KJUR.crypto.DSA();j.setPublic(new BigInteger(b,16),new BigInteger(a,16),new BigInteger(d,16),new BigInteger(h,16));return j}else{throw"unsupported key"}}}};X509.getPublicKeyInfoPropOfCertPEM=function(e){var c={};c.algparam=null;var g=X509.pemToHex(e);var d=ASN1HEX.getPosArrayOfChildren_AtObj(g,0);if(d.length!=3){throw"malformed X.509 certificate PEM (code:001)"}if(g.substr(d[0],2)!="30"){throw"malformed X.509 certificate PEM (code:002)"}var b=ASN1HEX.getPosArrayOfChildren_AtObj(g,d[0]);if(b.length<7){throw"malformed X.509 certificate PEM (code:003)"}var h=ASN1HEX.getPosArrayOfChildren_AtObj(g,b[6]);if(h.length!=2){throw"malformed X.509 certificate PEM (code:004)"}var f=ASN1HEX.getPosArrayOfChildren_AtObj(g,h[0]);if(f.length!=2){throw"malformed X.509 certificate PEM (code:005)"}c.algoid=ASN1HEX.getHexOfV_AtObj(g,f[0]);if(g.substr(f[1],2)=="06"){c.algparam=ASN1HEX.getHexOfV_AtObj(g,f[1])}else{if(g.substr(f[1],2)=="30"){c.algparam=ASN1HEX.getHexOfTLV_AtObj(g,f[1])}}if(g.substr(h[1],2)!="03"){throw"malformed X.509 certificate PEM (code:006)"}var a=ASN1HEX.getHexOfV_AtObj(g,h[1]);c.keyhex=a.substr(2);return c};

/*! crypto-1.1.5.js (c) 2013 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.crypto=="undefined"||!KJUR.crypto){KJUR.crypto={}}KJUR.crypto.Util=new function(){this.DIGESTINFOHEAD={sha1:"3021300906052b0e03021a05000414",sha224:"302d300d06096086480165030402040500041c",sha256:"3031300d060960864801650304020105000420",sha384:"3041300d060960864801650304020205000430",sha512:"3051300d060960864801650304020305000440",md2:"3020300c06082a864886f70d020205000410",md5:"3020300c06082a864886f70d020505000410",ripemd160:"3021300906052b2403020105000414",};this.DEFAULTPROVIDER={md5:"cryptojs",sha1:"cryptojs",sha224:"cryptojs",sha256:"cryptojs",sha384:"cryptojs",sha512:"cryptojs",ripemd160:"cryptojs",hmacmd5:"cryptojs",hmacsha1:"cryptojs",hmacsha224:"cryptojs",hmacsha256:"cryptojs",hmacsha384:"cryptojs",hmacsha512:"cryptojs",hmacripemd160:"cryptojs",MD5withRSA:"cryptojs/jsrsa",SHA1withRSA:"cryptojs/jsrsa",SHA224withRSA:"cryptojs/jsrsa",SHA256withRSA:"cryptojs/jsrsa",SHA384withRSA:"cryptojs/jsrsa",SHA512withRSA:"cryptojs/jsrsa",RIPEMD160withRSA:"cryptojs/jsrsa",MD5withECDSA:"cryptojs/jsrsa",SHA1withECDSA:"cryptojs/jsrsa",SHA224withECDSA:"cryptojs/jsrsa",SHA256withECDSA:"cryptojs/jsrsa",SHA384withECDSA:"cryptojs/jsrsa",SHA512withECDSA:"cryptojs/jsrsa",RIPEMD160withECDSA:"cryptojs/jsrsa",SHA1withDSA:"cryptojs/jsrsa",SHA224withDSA:"cryptojs/jsrsa",SHA256withDSA:"cryptojs/jsrsa",MD5withRSAandMGF1:"cryptojs/jsrsa",SHA1withRSAandMGF1:"cryptojs/jsrsa",SHA224withRSAandMGF1:"cryptojs/jsrsa",SHA256withRSAandMGF1:"cryptojs/jsrsa",SHA384withRSAandMGF1:"cryptojs/jsrsa",SHA512withRSAandMGF1:"cryptojs/jsrsa",RIPEMD160withRSAandMGF1:"cryptojs/jsrsa",};this.CRYPTOJSMESSAGEDIGESTNAME={md5:"CryptoJS.algo.MD5",sha1:"CryptoJS.algo.SHA1",sha224:"CryptoJS.algo.SHA224",sha256:"CryptoJS.algo.SHA256",sha384:"CryptoJS.algo.SHA384",sha512:"CryptoJS.algo.SHA512",ripemd160:"CryptoJS.algo.RIPEMD160"};this.getDigestInfoHex=function(a,b){if(typeof this.DIGESTINFOHEAD[b]=="undefined"){throw"alg not supported in Util.DIGESTINFOHEAD: "+b}return this.DIGESTINFOHEAD[b]+a};this.getPaddedDigestInfoHex=function(h,a,j){var c=this.getDigestInfoHex(h,a);var d=j/4;if(c.length+22>d){throw"key is too short for SigAlg: keylen="+j+","+a}var b="0001";var k="00"+c;var g="";var l=d-b.length-k.length;for(var f=0;f<l;f+=2){g+="ff"}var e=b+g+k;return e};this.hashString=function(a,c){var b=new KJUR.crypto.MessageDigest({alg:c});return b.digestString(a)};this.hashHex=function(b,c){var a=new KJUR.crypto.MessageDigest({alg:c});return a.digestHex(b)};this.sha1=function(a){var b=new KJUR.crypto.MessageDigest({alg:"sha1",prov:"cryptojs"});return b.digestString(a)};this.sha256=function(a){var b=new KJUR.crypto.MessageDigest({alg:"sha256",prov:"cryptojs"});return b.digestString(a)};this.sha256Hex=function(a){var b=new KJUR.crypto.MessageDigest({alg:"sha256",prov:"cryptojs"});return b.digestHex(a)};this.sha512=function(a){var b=new KJUR.crypto.MessageDigest({alg:"sha512",prov:"cryptojs"});return b.digestString(a)};this.sha512Hex=function(a){var b=new KJUR.crypto.MessageDigest({alg:"sha512",prov:"cryptojs"});return b.digestHex(a)};this.md5=function(a){var b=new KJUR.crypto.MessageDigest({alg:"md5",prov:"cryptojs"});return b.digestString(a)};this.ripemd160=function(a){var b=new KJUR.crypto.MessageDigest({alg:"ripemd160",prov:"cryptojs"});return b.digestString(a)};this.getCryptoJSMDByName=function(a){}};KJUR.crypto.MessageDigest=function(params){var md=null;var algName=null;var provName=null;this.setAlgAndProvider=function(alg,prov){if(alg!=null&&prov===undefined){prov=KJUR.crypto.Util.DEFAULTPROVIDER[alg]}if(":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(alg)!=-1&&prov=="cryptojs"){try{this.md=eval(KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[alg]).create()}catch(ex){throw"setAlgAndProvider hash alg set fail alg="+alg+"/"+ex}this.updateString=function(str){this.md.update(str)};this.updateHex=function(hex){var wHex=CryptoJS.enc.Hex.parse(hex);this.md.update(wHex)};this.digest=function(){var hash=this.md.finalize();return hash.toString(CryptoJS.enc.Hex)};this.digestString=function(str){this.updateString(str);return this.digest()};this.digestHex=function(hex){this.updateHex(hex);return this.digest()}}if(":sha256:".indexOf(alg)!=-1&&prov=="sjcl"){try{this.md=new sjcl.hash.sha256()}catch(ex){throw"setAlgAndProvider hash alg set fail alg="+alg+"/"+ex}this.updateString=function(str){this.md.update(str)};this.updateHex=function(hex){var baHex=sjcl.codec.hex.toBits(hex);this.md.update(baHex)};this.digest=function(){var hash=this.md.finalize();return sjcl.codec.hex.fromBits(hash)};this.digestString=function(str){this.updateString(str);return this.digest()};this.digestHex=function(hex){this.updateHex(hex);return this.digest()}}};this.updateString=function(str){throw"updateString(str) not supported for this alg/prov: "+this.algName+"/"+this.provName};this.updateHex=function(hex){throw"updateHex(hex) not supported for this alg/prov: "+this.algName+"/"+this.provName};this.digest=function(){throw"digest() not supported for this alg/prov: "+this.algName+"/"+this.provName};this.digestString=function(str){throw"digestString(str) not supported for this alg/prov: "+this.algName+"/"+this.provName};this.digestHex=function(hex){throw"digestHex(hex) not supported for this alg/prov: "+this.algName+"/"+this.provName};if(params!==undefined){if(params.alg!==undefined){this.algName=params.alg;if(params.prov===undefined){this.provName=KJUR.crypto.Util.DEFAULTPROVIDER[this.algName]}this.setAlgAndProvider(this.algName,this.provName)}}};KJUR.crypto.Mac=function(params){var mac=null;var pass=null;var algName=null;var provName=null;var algProv=null;this.setAlgAndProvider=function(alg,prov){if(alg==null){alg="hmacsha1"}alg=alg.toLowerCase();if(alg.substr(0,4)!="hmac"){throw"setAlgAndProvider unsupported HMAC alg: "+alg}if(prov===undefined){prov=KJUR.crypto.Util.DEFAULTPROVIDER[alg]}this.algProv=alg+"/"+prov;var hashAlg=alg.substr(4);if(":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(hashAlg)!=-1&&prov=="cryptojs"){try{var mdObj=eval(KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[hashAlg]);this.mac=CryptoJS.algo.HMAC.create(mdObj,this.pass)}catch(ex){throw"setAlgAndProvider hash alg set fail hashAlg="+hashAlg+"/"+ex}this.updateString=function(str){this.mac.update(str)};this.updateHex=function(hex){var wHex=CryptoJS.enc.Hex.parse(hex);this.mac.update(wHex)};this.doFinal=function(){var hash=this.mac.finalize();return hash.toString(CryptoJS.enc.Hex)};this.doFinalString=function(str){this.updateString(str);return this.doFinal()};this.doFinalHex=function(hex){this.updateHex(hex);return this.doFinal()}}};this.updateString=function(str){throw"updateString(str) not supported for this alg/prov: "+this.algProv};this.updateHex=function(hex){throw"updateHex(hex) not supported for this alg/prov: "+this.algProv};this.doFinal=function(){throw"digest() not supported for this alg/prov: "+this.algProv};this.doFinalString=function(str){throw"digestString(str) not supported for this alg/prov: "+this.algProv};this.doFinalHex=function(hex){throw"digestHex(hex) not supported for this alg/prov: "+this.algProv};if(params!==undefined){if(params.pass!==undefined){this.pass=params.pass}if(params.alg!==undefined){this.algName=params.alg;if(params.prov===undefined){this.provName=KJUR.crypto.Util.DEFAULTPROVIDER[this.algName]}this.setAlgAndProvider(this.algName,this.provName)}}};KJUR.crypto.Signature=function(o){var q=null;var n=null;var r=null;var c=null;var l=null;var d=null;var k=null;var h=null;var p=null;var e=null;var b=-1;var g=null;var j=null;var a=null;var i=null;var f=null;this._setAlgNames=function(){if(this.algName.match(/^(.+)with(.+)$/)){this.mdAlgName=RegExp.$1.toLowerCase();this.pubkeyAlgName=RegExp.$2.toLowerCase()}};this._zeroPaddingOfSignature=function(x,w){var v="";var t=w/4-x.length;for(var u=0;u<t;u++){v=v+"0"}return v+x};this.setAlgAndProvider=function(u,t){this._setAlgNames();if(t!="cryptojs/jsrsa"){throw"provider not supported: "+t}if(":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(this.mdAlgName)!=-1){try{this.md=new KJUR.crypto.MessageDigest({alg:this.mdAlgName})}catch(s){throw"setAlgAndProvider hash alg set fail alg="+this.mdAlgName+"/"+s}this.init=function(w,x){var y=null;try{if(x===undefined){y=KEYUTIL.getKey(w)}else{y=KEYUTIL.getKey(w,x)}}catch(v){throw"init failed:"+v}if(y.isPrivate===true){this.prvKey=y;this.state="SIGN"}else{if(y.isPublic===true){this.pubKey=y;this.state="VERIFY"}else{throw"init failed.:"+y}}};this.initSign=function(v){if(typeof v.ecprvhex=="string"&&typeof v.eccurvename=="string"){this.ecprvhex=v.ecprvhex;this.eccurvename=v.eccurvename}else{this.prvKey=v}this.state="SIGN"};this.initVerifyByPublicKey=function(v){if(typeof v.ecpubhex=="string"&&typeof v.eccurvename=="string"){this.ecpubhex=v.ecpubhex;this.eccurvename=v.eccurvename}else{if(v instanceof KJUR.crypto.ECDSA){this.pubKey=v}else{if(v instanceof RSAKey){this.pubKey=v}}}this.state="VERIFY"};this.initVerifyByCertificatePEM=function(v){var w=new X509();w.readCertPEM(v);this.pubKey=w.subjectPublicKeyRSA;this.state="VERIFY"};this.updateString=function(v){this.md.updateString(v)};this.updateHex=function(v){this.md.updateHex(v)};this.sign=function(){this.sHashHex=this.md.digest();if(typeof this.ecprvhex!="undefined"&&typeof this.eccurvename!="undefined"){var v=new KJUR.crypto.ECDSA({curve:this.eccurvename});this.hSign=v.signHex(this.sHashHex,this.ecprvhex)}else{if(this.pubkeyAlgName=="rsaandmgf1"){this.hSign=this.prvKey.signWithMessageHashPSS(this.sHashHex,this.mdAlgName,this.pssSaltLen)}else{if(this.pubkeyAlgName=="rsa"){this.hSign=this.prvKey.signWithMessageHash(this.sHashHex,this.mdAlgName)}else{if(this.prvKey instanceof KJUR.crypto.ECDSA){this.hSign=this.prvKey.signWithMessageHash(this.sHashHex)}else{if(this.prvKey instanceof KJUR.crypto.DSA){this.hSign=this.prvKey.signWithMessageHash(this.sHashHex)}else{throw"Signature: unsupported public key alg: "+this.pubkeyAlgName}}}}}return this.hSign};this.signString=function(v){this.updateString(v);this.sign()};this.signHex=function(v){this.updateHex(v);this.sign()};this.verify=function(v){this.sHashHex=this.md.digest();if(typeof this.ecpubhex!="undefined"&&typeof this.eccurvename!="undefined"){var w=new KJUR.crypto.ECDSA({curve:this.eccurvename});return w.verifyHex(this.sHashHex,v,this.ecpubhex)}else{if(this.pubkeyAlgName=="rsaandmgf1"){return this.pubKey.verifyWithMessageHashPSS(this.sHashHex,v,this.mdAlgName,this.pssSaltLen)}else{if(this.pubkeyAlgName=="rsa"){return this.pubKey.verifyWithMessageHash(this.sHashHex,v)}else{if(this.pubKey instanceof KJUR.crypto.ECDSA){return this.pubKey.verifyWithMessageHash(this.sHashHex,v)}else{if(this.pubKey instanceof KJUR.crypto.DSA){return this.pubKey.verifyWithMessageHash(this.sHashHex,v)}else{throw"Signature: unsupported public key alg: "+this.pubkeyAlgName}}}}}}}};this.init=function(s,t){throw"init(key, pass) not supported for this alg:prov="+this.algProvName};this.initVerifyByPublicKey=function(s){throw"initVerifyByPublicKey(rsaPubKeyy) not supported for this alg:prov="+this.algProvName};this.initVerifyByCertificatePEM=function(s){throw"initVerifyByCertificatePEM(certPEM) not supported for this alg:prov="+this.algProvName};this.initSign=function(s){throw"initSign(prvKey) not supported for this alg:prov="+this.algProvName};this.updateString=function(s){throw"updateString(str) not supported for this alg:prov="+this.algProvName};this.updateHex=function(s){throw"updateHex(hex) not supported for this alg:prov="+this.algProvName};this.sign=function(){throw"sign() not supported for this alg:prov="+this.algProvName};this.signString=function(s){throw"digestString(str) not supported for this alg:prov="+this.algProvName};this.signHex=function(s){throw"digestHex(hex) not supported for this alg:prov="+this.algProvName};this.verify=function(s){throw"verify(hSigVal) not supported for this alg:prov="+this.algProvName};this.initParams=o;if(o!==undefined){if(o.alg!==undefined){this.algName=o.alg;if(o.prov===undefined){this.provName=KJUR.crypto.Util.DEFAULTPROVIDER[this.algName]}else{this.provName=o.prov}this.algProvName=this.algName+":"+this.provName;this.setAlgAndProvider(this.algName,this.provName);this._setAlgNames()}if(o.psssaltlen!==undefined){this.pssSaltLen=o.psssaltlen}if(o.prvkeypem!==undefined){if(o.prvkeypas!==undefined){throw"both prvkeypem and prvkeypas parameters not supported"}else{try{var q=new RSAKey();q.readPrivateKeyFromPEMString(o.prvkeypem);this.initSign(q)}catch(m){throw"fatal error to load pem private key: "+m}}}}};KJUR.crypto.OID=new function(){this.oidhex2name={"2a864886f70d010101":"rsaEncryption","2a8648ce3d0201":"ecPublicKey","2a8648ce380401":"dsa","2a8648ce3d030107":"secp256r1","2b8104001f":"secp192k1","2b81040021":"secp224r1","2b8104000a":"secp256k1","2b81040023":"secp521r1","2b81040022":"secp384r1","2a8648ce380403":"SHA1withDSA","608648016503040301":"SHA224withDSA","608648016503040302":"SHA256withDSA",}};

d20.DicePEG = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "start": parse_start,
        "rollExpression": parse_rollExpression,
        "rollExpressionPrimary": parse_rollExpressionPrimary,
        "validRollSuffix": parse_validRollSuffix,
        "rollGroup": parse_rollGroup,
        "rollGroupExpression": parse_rollGroupExpression,
        "labelAwareRollOperator": parse_labelAwareRollOperator,
        "rollOperator": parse_rollOperator,
        "fullRoll": parse_fullRoll,
        "coreRoll": parse_coreRoll,
        "numberOfDice": parse_numberOfDice,
        "numberOfSides": parse_numberOfSides,
        "groupMods": parse_groupMods,
        "rollMods": parse_rollMods,
        "explodingMod": parse_explodingMod,
        "compoundingMod": parse_compoundingMod,
        "penetratingMod": parse_penetratingMod,
        "keepMod": parse_keepMod,
        "dropMod": parse_dropMod,
        "customCritMod": parse_customCritMod,
        "customFumbleMod": parse_customFumbleMod,
        "rerollMod": parse_rerollMod,
        "rerollOnceMod": parse_rerollOnceMod,
        "sortMod": parse_sortMod,
        "floorMod": parse_floorMod,
        "multipleMod": parse_multipleMod,
        "successMod": parse_successMod,
        "matchMod": parse_matchMod,
        "matchTotalMod": parse_matchTotalMod,
        "matchThreshold": parse_matchThreshold,
        "comparisonPoint": parse_comparisonPoint,
        "comparison": parse_comparison,
        "mathExpression": parse_mathExpression,
        "mathExpressionPrimary": parse_mathExpressionPrimary,
        "inlineLabelWithSpace": parse_inlineLabelWithSpace,
        "inlineLabel": parse_inlineLabel,
        "operator": parse_operator,
        "number": parse_number,
        "integer": parse_integer,
        "signedInteger": parse_signedInteger,
        "float": parse_float,
        "exponent": parse_exponent,
        "_": parse__,
        "__": parse___
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "start";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_start() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_rollExpression();
        if (result0 !== null) {
          result1 = [];
          if (input.length > pos) {
            result2 = input.charAt(pos);
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("any character");
            }
          }
          while (result2 !== null) {
            result1.push(result2);
            if (input.length > pos) {
              result2 = input.charAt(pos);
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("any character");
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, re, com) {
            if (!Array.isArray(re)) {
              re = [re];
            }
        
            //If a comment exists append it to the end of the roll expression
            if (com !== "") {
              com = com.join("");
              if (com.trim().length > 0) {
                re.push(new Comment(com));
              }
            }
        
            return re;
          })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_rollExpression() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_rollExpressionPrimary();
        if (result0 !== null) {
          result1 = parse_labelAwareRollOperator();
          if (result1 !== null) {
            result2 = parse_rollExpression();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, left, oper, right) {
            var result = left;
            result = mergeExpressions(result, oper);
            result = mergeExpressions(result, right);
            return result;
          })(pos0, result0[0], result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_rollExpressionPrimary();
          if (result0 !== null) {
            result1 = parse_inlineLabelWithSpace();
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, rep, lbl) {
              return mergeExpressions(rep, lbl);
            })(pos0, result0[0], result0[1]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            result0 = parse_inlineLabelWithSpace();
            if (result0 !== null) {
              result1 = parse_rollExpression();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, lbl, re) {
                return mergeExpressions(lbl, re);
              })(pos0, result0[0], result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              result0 = parse_rollExpressionPrimary();
              if (result0 !== null) {
                result0 = (function(offset, rep) {
                  if (!Array.isArray(rep)) {
                    rep = [rep];
                  }
                  return rep;
                })(pos0, result0);
              }
              if (result0 === null) {
                pos = pos0;
              }
            }
          }
        }
        return result0;
      }
      
      function parse_rollExpressionPrimary() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_fullRoll();
        if (result0 !== null) {
          pos2 = pos;
          reportFailures++;
          result1 = parse_validRollSuffix();
          reportFailures--;
          if (result1 !== null) {
            result1 = "";
            pos = pos2;
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, fr) {
            return fr;
          })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_rollGroup();
          if (result0 !== null) {
            pos2 = pos;
            reportFailures++;
            result1 = parse_validRollSuffix();
            reportFailures--;
            if (result1 !== null) {
              result1 = "";
              pos = pos2;
            } else {
              result1 = null;
            }
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, rg) {
              return rg;
            })(pos0, result0[0]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            result0 = parse_number();
            if (result0 !== null) {
              result0 = (function(offset, num) {
                return new MathExpression(num);
              })(pos0, result0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              pos1 = pos;
              if (input.substr(pos, 6) === "floor(") {
                result0 = "floor(";
                pos += 6;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"floor(\"");
                }
              }
              if (result0 !== null) {
                result1 = parse__();
                if (result1 !== null) {
                  result2 = parse_rollExpression();
                  if (result2 !== null) {
                    result3 = parse__();
                    if (result3 !== null) {
                      if (input.charCodeAt(pos) === 41) {
                        result4 = ")";
                        pos++;
                      } else {
                        result4 = null;
                        if (reportFailures === 0) {
                          matchFailed("\")\"");
                        }
                      }
                      if (result4 !== null) {
                        result0 = [result0, result1, result2, result3, result4];
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 !== null) {
                result0 = (function(offset, rexp) {
              
                  return mergeExpressions("floor(", mergeExpressions(rexp, ")"));
                })(pos0, result0[2]);
              }
              if (result0 === null) {
                pos = pos0;
              }
              if (result0 === null) {
                pos0 = pos;
                pos1 = pos;
                if (input.substr(pos, 5) === "ceil(") {
                  result0 = "ceil(";
                  pos += 5;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"ceil(\"");
                  }
                }
                if (result0 !== null) {
                  result1 = parse__();
                  if (result1 !== null) {
                    result2 = parse_rollExpression();
                    if (result2 !== null) {
                      result3 = parse__();
                      if (result3 !== null) {
                        if (input.charCodeAt(pos) === 41) {
                          result4 = ")";
                          pos++;
                        } else {
                          result4 = null;
                          if (reportFailures === 0) {
                            matchFailed("\")\"");
                          }
                        }
                        if (result4 !== null) {
                          result0 = [result0, result1, result2, result3, result4];
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
                if (result0 !== null) {
                  result0 = (function(offset, rexp) {
                
                    return mergeExpressions("ceil(", mergeExpressions(rexp, ")"));
                  })(pos0, result0[2]);
                }
                if (result0 === null) {
                  pos = pos0;
                }
                if (result0 === null) {
                  pos0 = pos;
                  pos1 = pos;
                  if (input.substr(pos, 6) === "round(") {
                    result0 = "round(";
                    pos += 6;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"round(\"");
                    }
                  }
                  if (result0 !== null) {
                    result1 = parse__();
                    if (result1 !== null) {
                      result2 = parse_rollExpression();
                      if (result2 !== null) {
                        result3 = parse__();
                        if (result3 !== null) {
                          if (input.charCodeAt(pos) === 41) {
                            result4 = ")";
                            pos++;
                          } else {
                            result4 = null;
                            if (reportFailures === 0) {
                              matchFailed("\")\"");
                            }
                          }
                          if (result4 !== null) {
                            result0 = [result0, result1, result2, result3, result4];
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                  if (result0 !== null) {
                    result0 = (function(offset, rexp) {
                  
                      return mergeExpressions("round(", mergeExpressions(rexp, ")"));
                    })(pos0, result0[2]);
                  }
                  if (result0 === null) {
                    pos = pos0;
                  }
                  if (result0 === null) {
                    pos0 = pos;
                    pos1 = pos;
                    if (input.substr(pos, 4) === "abs(") {
                      result0 = "abs(";
                      pos += 4;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"abs(\"");
                      }
                    }
                    if (result0 !== null) {
                      result1 = parse__();
                      if (result1 !== null) {
                        result2 = parse_rollExpression();
                        if (result2 !== null) {
                          result3 = parse__();
                          if (result3 !== null) {
                            if (input.charCodeAt(pos) === 41) {
                              result4 = ")";
                              pos++;
                            } else {
                              result4 = null;
                              if (reportFailures === 0) {
                                matchFailed("\")\"");
                              }
                            }
                            if (result4 !== null) {
                              result0 = [result0, result1, result2, result3, result4];
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                    if (result0 !== null) {
                      result0 = (function(offset, rexp) {
                    
                        return mergeExpressions("abs(", mergeExpressions(rexp, ")"));
                      })(pos0, result0[2]);
                    }
                    if (result0 === null) {
                      pos = pos0;
                    }
                    if (result0 === null) {
                      pos0 = pos;
                      pos1 = pos;
                      if (input.charCodeAt(pos) === 40) {
                        result0 = "(";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"(\"");
                        }
                      }
                      if (result0 !== null) {
                        result1 = parse__();
                        if (result1 !== null) {
                          result2 = parse_rollExpression();
                          if (result2 !== null) {
                            result3 = parse__();
                            if (result3 !== null) {
                              if (input.charCodeAt(pos) === 41) {
                                result4 = ")";
                                pos++;
                              } else {
                                result4 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\")\"");
                                }
                              }
                              if (result4 !== null) {
                                result0 = [result0, result1, result2, result3, result4];
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                      if (result0 !== null) {
                        result0 = (function(offset, rexp) {
                      
                          return mergeExpressions("(", mergeExpressions(rexp, ")"));
                        })(pos0, result0[2]);
                      }
                      if (result0 === null) {
                        pos = pos0;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_validRollSuffix() {
        var result0;
        var pos0;
        
        result0 = parse___();
        if (result0 === null) {
          result0 = parse_inlineLabelWithSpace();
          if (result0 === null) {
            if (input.charCodeAt(pos) === 125) {
              result0 = "}";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"}\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 44) {
                result0 = ",";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\",\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 41) {
                  result0 = ")";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\")\"");
                  }
                }
                if (result0 === null) {
                  pos0 = pos;
                  reportFailures++;
                  result0 = parse_operator();
                  reportFailures--;
                  if (result0 !== null) {
                    result0 = "";
                    pos = pos0;
                  } else {
                    result0 = null;
                  }
                  if (result0 === null) {
                    pos0 = pos;
                    reportFailures++;
                    if (input.length > pos) {
                      result0 = input.charAt(pos);
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("any character");
                      }
                    }
                    reportFailures--;
                    if (result0 === null) {
                      result0 = "";
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_rollGroup() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 123) {
          result0 = "{";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"{\"");
          }
        }
        if (result0 !== null) {
          result1 = parse__();
          if (result1 !== null) {
            result2 = parse_rollGroupExpression();
            if (result2 !== null) {
              result3 = parse__();
              if (result3 !== null) {
                if (input.charCodeAt(pos) === 125) {
                  result4 = "}";
                  pos++;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"}\"");
                  }
                }
                if (result4 !== null) {
                  result5 = parse_groupMods();
                  result5 = result5 !== null ? result5 : "";
                  if (result5 !== null) {
                    result0 = [result0, result1, result2, result3, result4, result5];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, rolls, mod) {
            return new GroupExpression(rolls, mod);
          })(pos0, result0[2], result0[5]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_rollGroupExpression() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_rollExpression();
        if (result0 === null) {
          result0 = parse_rollGroup();
        }
        if (result0 !== null) {
          result1 = parse__();
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 44) {
              result2 = ",";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\",\"");
              }
            }
            if (result2 !== null) {
              result3 = parse__();
              if (result3 !== null) {
                result4 = parse_rollGroupExpression();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, left, right) {
            if (!Array.isArray(left)) {
              left = [left];
            }
            if (right !== "") {
              return [left].concat(right);
            }
        
            return left;
          })(pos0, result0[0], result0[4]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          result0 = parse_rollExpression();
          if (result0 === null) {
            result0 = parse_rollGroup();
          }
          if (result0 !== null) {
            result0 = (function(offset, left) { 
              return [left];
            })(pos0, result0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_labelAwareRollOperator() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_rollOperator();
        if (result0 !== null) {
          result1 = [];
          result2 = parse_rollOperator();
          if (result2 === null) {
            result2 = parse_inlineLabelWithSpace();
          }
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_rollOperator();
            if (result2 === null) {
              result2 = parse_inlineLabelWithSpace();
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, oper, addl) {
            var result = oper;
            for (var i = 0; i < addl.length; i++) {
              result = mergeExpressions(result, addl[i]);
            }
            return result;
          })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_inlineLabelWithSpace();
          if (result0 !== null) {
            result1 = parse_labelAwareRollOperator();
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, lbl, oper) {
              return mergeExpressions(lbl, oper);
           })(pos0, result0[0], result0[1]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_rollOperator() {
        var result0, result1, result2, result3, result4, result5, result6;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse__();
        if (result0 !== null) {
          result1 = parse_operator();
          if (result1 !== null) {
            result2 = parse__();
            if (result2 !== null) {
              result3 = parse_mathExpressionPrimary();
              if (result3 !== null) {
                result4 = parse__();
                if (result4 !== null) {
                  result5 = parse_rollOperator();
                  if (result5 !== null) {
                    result6 = parse__();
                    if (result6 !== null) {
                      result0 = [result0, result1, result2, result3, result4, result5, result6];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, left, num, right) {
            return left + num + right;
          })(pos0, result0[1], result0[3], result0[5]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse__();
          if (result0 !== null) {
            result1 = parse_operator();
            if (result1 !== null) {
              result2 = parse__();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, oper) {
              return oper;
            })(pos0, result0[1]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_fullRoll() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_coreRoll();
        if (result0 !== null) {
          result1 = parse_rollMods();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, roll, mod) {
            if (mod !== "") {
              roll.mods = mod;
            }
        
            return roll;
          })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_numberOfDice();
          if (result0 !== null) {
            if (input.substr(pos, 1).toLowerCase() === "t") {
              result1 = input.substr(pos, 1);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"t\"");
              }
            }
            if (result1 !== null) {
              result2 = parse_inlineLabel();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, count, table) {
              return new TableRollExpression(count, table.text);
            })(pos0, result0[0], result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_coreRoll() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_numberOfDice();
        if (result0 !== null) {
          if (input.substr(pos, 1).toLowerCase() === "d") {
            result1 = input.substr(pos, 1);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"d\"");
            }
          }
          if (result1 !== null) {
            if (input.substr(pos, 1).toLowerCase() === "f") {
              result2 = input.substr(pos, 1);
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"f\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, count) {
            return new FateRollExpression(count);
          })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_numberOfDice();
          if (result0 !== null) {
            if (input.substr(pos, 1).toLowerCase() === "d") {
              result1 = input.substr(pos, 1);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"d\"");
              }
            }
            if (result1 !== null) {
              result2 = parse_numberOfSides();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, count, sides) {
              return new RollExpression(count, sides);
            })(pos0, result0[0], result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_numberOfDice() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        result0 = parse_integer();
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 40) {
            result0 = "(";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"(\"");
            }
          }
          if (result0 !== null) {
            result1 = parse__();
            if (result1 !== null) {
              result2 = parse_mathExpression();
              if (result2 !== null) {
                result3 = parse__();
                if (result3 !== null) {
                  if (input.charCodeAt(pos) === 41) {
                    result4 = ")";
                    pos++;
                  } else {
                    result4 = null;
                    if (reportFailures === 0) {
                      matchFailed("\")\"");
                    }
                  }
                  if (result4 !== null) {
                    result0 = [result0, result1, result2, result3, result4];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, expr) {
              return Math.round(eval("(" + expr + ")"));
            })(pos0, result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            result0 = "";
            if (result0 !== null) {
              result0 = (function(offset) { return 1; })(pos0);
            }
            if (result0 === null) {
              pos = pos0;
            }
          }
        }
        return result0;
      }
      
      function parse_numberOfSides() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        result0 = parse_integer();
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 40) {
            result0 = "(";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"(\"");
            }
          }
          if (result0 !== null) {
            result1 = parse__();
            if (result1 !== null) {
              result2 = parse_mathExpression();
              if (result2 !== null) {
                result3 = parse__();
                if (result3 !== null) {
                  if (input.charCodeAt(pos) === 41) {
                    result4 = ")";
                    pos++;
                  } else {
                    result4 = null;
                    if (reportFailures === 0) {
                      matchFailed("\")\"");
                    }
                  }
                  if (result4 !== null) {
                    result0 = [result0, result1, result2, result3, result4];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, expr) {
              return Math.round(eval("(" + expr + ")"));
            })(pos0, result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            if (input.substr(pos, 1).toLowerCase() === "f") {
              result0 = input.substr(pos, 1);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"f\"");
              }
            }
            if (result0 !== null) {
              result0 = (function(offset) { return "F"; })(pos0);
            }
            if (result0 === null) {
              pos = pos0;
            }
          }
        }
        return result0;
      }
      
      function parse_groupMods() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_keepMod();
        if (result0 === null) {
          result0 = parse_dropMod();
          if (result0 === null) {
            result0 = parse_multipleMod();
            if (result0 === null) {
              result0 = parse_matchTotalMod();
              if (result0 === null) {
                result0 = parse_matchMod();
                if (result0 === null) {
                  result0 = parse_successMod();
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_groupMods();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_groupMods();
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, head, tail) {
            return processMods(head, tail);
          })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_rollMods() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_compoundingMod();
        if (result0 === null) {
          result0 = parse_penetratingMod();
          if (result0 === null) {
            result0 = parse_explodingMod();
            if (result0 === null) {
              result0 = parse_keepMod();
              if (result0 === null) {
                result0 = parse_dropMod();
                if (result0 === null) {
                  result0 = parse_rerollOnceMod();
                  if (result0 === null) {
                    result0 = parse_rerollMod();
                    if (result0 === null) {
                      result0 = parse_customCritMod();
                      if (result0 === null) {
                        result0 = parse_customFumbleMod();
                        if (result0 === null) {
                          result0 = parse_sortMod();
                          if (result0 === null) {
                            result0 = parse_matchTotalMod();
                            if (result0 === null) {
                              result0 = parse_matchMod();
                              if (result0 === null) {
                                result0 = parse_successMod();
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_rollMods();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_rollMods();
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, head, tail) {
            return processMods(head, tail);
          })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_explodingMod() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 33) {
          result0 = "!";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"!\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_comparisonPoint();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, cp) {
            return { 
              exploding: cp
            };
          })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_compoundingMod() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 2) === "!!") {
          result0 = "!!";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"!!\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_comparisonPoint();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, cp) {
            return { 
              compounding: cp
            };
          })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_penetratingMod() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 33) {
          result0 = "!";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"!\"");
          }
        }
        if (result0 !== null) {
          if (input.substr(pos, 1).toLowerCase() === "p") {
            result1 = input.substr(pos, 1);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"p\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_comparisonPoint();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, cp) {
            return { 
              penetrating: cp
            };
          })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_keepMod() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 1).toLowerCase() === "k") {
          result0 = input.substr(pos, 1);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"k\"");
          }
        }
        if (result0 !== null) {
          if (/^['h'|'l']/i.test(input.charAt(pos))) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("['h'|'l']i");
            }
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_integer();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, hl, count) {
            return { 
              keep: {
                end: (hl.toLowerCase() || 'h'),
                count:count
              }
            };
          })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_dropMod() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 1).toLowerCase() === "d") {
          result0 = input.substr(pos, 1);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"d\"");
          }
        }
        if (result0 !== null) {
          if (/^['h'|'l']/i.test(input.charAt(pos))) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("['h'|'l']i");
            }
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_integer();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, hl, count) {
            return { 
              drop: {
                end: (hl.toLowerCase() || 'l'),
                count:count
              }
            };
          })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_customCritMod() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 2).toLowerCase() === "cs") {
          result0 = input.substr(pos, 2);
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"cs\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_comparisonPoint();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_customCritMod();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, cp, tail) {
            var result = {
              customCrit: (cp !== "" ? [cp] : [{}])
            };
        
            if (tail !== "") {
              result.customCrit = result.customCrit.concat(tail.customCrit);
            }
        
            return result;
          })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_customFumbleMod() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 2).toLowerCase() === "cf") {
          result0 = input.substr(pos, 2);
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"cf\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_comparisonPoint();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_customFumbleMod();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, cp, tail) {
            var result = {
              customFumble: (cp !== "" ? [cp] : [{}])
            };
        
            if (tail !== "") {
              result.customFumble = result.customFumble.concat(tail.customFumble);
            }
        
            return result;
          })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_rerollMod() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 1).toLowerCase() === "r") {
          result0 = input.substr(pos, 1);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"r\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_comparisonPoint();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_rerollMod();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, cp, tail) {
            var result = {
              reroll: (cp !== "" ? [cp] : [{}])
            };
        
            if (tail !== "") {
                result.reroll = result.reroll.concat(tail.reroll);
            }
        
            return result;
          })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_rerollOnceMod() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 2).toLowerCase() === "ro") {
          result0 = input.substr(pos, 2);
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"ro\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_comparisonPoint();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_rerollMod();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, cp, tail) {
            var result = {
              reroll: (cp !== "" ? [cp] : [{}])
            };
        
            if (tail !== "") {
                result.reroll = result.reroll.concat(tail.reroll);
            }
        
            if(result.reroll && result.reroll[0]) result.reroll[0].maxrerolls = 1;
        
            return result;
          })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_sortMod() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 1).toLowerCase() === "s") {
          result0 = input.substr(pos, 1);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"s\"");
          }
        }
        if (result0 !== null) {
          if (/^['a'|'d']/i.test(input.charAt(pos))) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("['a'|'d']i");
            }
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, order) {
            return { 
              sort: {
                order: (order.toLowerCase() || 'a')
              }
            };
          })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_floorMod() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 3) === "flr") {
          result0 = "flr";
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"flr\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
            return {
              round: {
                type: "floor"
              }
            };
          })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_multipleMod() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 1).toLowerCase() === "x") {
          result0 = input.substr(pos, 1);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"x\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_integer();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, times) {
            return { 
              multiple: {
                times: times
              }
            };
          })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_successMod() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_comparisonPoint();
        if (result0 !== null) {
          pos2 = pos;
          if (input.substr(pos, 1).toLowerCase() === "f") {
            result1 = input.substr(pos, 1);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"f\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_comparisonPoint();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, cp, failure) {
            var result = { 
              success: cp
            };
        
            if (failure !== "") {
              result["failure"] = failure[1];
            }
        
            return result;
          })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_matchMod() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 109) {
          result0 = "m";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"m\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_matchThreshold();
          if (result1 !== null) {
            result2 = parse_comparisonPoint();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, mt, cp) {
            var result = {
              match: (cp !== "" ? cp : {})
            };
            result.match["threshold"] = mt;
        
            return result;
          })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_matchTotalMod() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 2) === "mt") {
          result0 = "mt";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"mt\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_matchThreshold();
          if (result1 !== null) {
            result2 = parse_comparisonPoint();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, mt, cp) {
            var result = {
              match: (cp !== "" ? cp : {})
            };
            result.match["threshold"] = mt;
            result.match["total"] = true;
        
            return result;
          })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_matchThreshold() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result0 = [];
        if (/^[0-9]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9]");
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          if (/^[0-9]/.test(input.charAt(pos))) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("[0-9]");
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, num) { 
            var result = num && num != [] && parseInt(num.join(""), 10) > 2 ? parseInt(num.join(""), 10) : 2;
            return result
          })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_comparisonPoint() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_comparison();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_integer();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, comp, point) {
            return {
              comp:(comp == "" ? "=" : comp) + "=", 
              point:point
            };
          })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_comparison() {
        var result0;
        
        if (/^[>|<|=]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[>|<|=]");
          }
        }
        return result0;
      }
      
      function parse_mathExpression() {
        var result0, result1, result2, result3, result4, result5, result6;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse__();
        if (result0 !== null) {
          result1 = parse_mathExpressionPrimary();
          if (result1 !== null) {
            result2 = parse__();
            if (result2 !== null) {
              result3 = parse_operator();
              if (result3 !== null) {
                result4 = parse__();
                if (result4 !== null) {
                  result5 = parse_mathExpression();
                  if (result5 !== null) {
                    result6 = parse__();
                    if (result6 !== null) {
                      result0 = [result0, result1, result2, result3, result4, result5, result6];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, left, oper, right) {
            return left + oper + right;
          })(pos0, result0[1], result0[3], result0[5]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse__();
          if (result0 !== null) {
            result1 = parse_mathExpressionPrimary();
            if (result1 !== null) {
              result2 = parse__();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, expr) {
              return expr;
            })(pos0, result0[1]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_mathExpressionPrimary() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse__();
        if (result0 !== null) {
          result1 = parse_number();
          if (result1 !== null) {
            result2 = parse__();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, num) {
            return num;
          })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 40) {
            result0 = "(";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"(\"");
            }
          }
          if (result0 !== null) {
            result1 = parse__();
            if (result1 !== null) {
              result2 = parse_mathExpression();
              if (result2 !== null) {
                result3 = parse__();
                if (result3 !== null) {
                  if (input.charCodeAt(pos) === 41) {
                    result4 = ")";
                    pos++;
                  } else {
                    result4 = null;
                    if (reportFailures === 0) {
                      matchFailed("\")\"");
                    }
                  }
                  if (result4 !== null) {
                    result0 = [result0, result1, result2, result3, result4];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, expr) {
              return "(" + expr + ")";
            })(pos0, result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_inlineLabelWithSpace() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse__();
        if (result0 !== null) {
          result1 = parse_inlineLabel();
          if (result1 !== null) {
            result2 = parse__();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, lbl) { 
            return lbl;
          })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_inlineLabel() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 91) {
          result0 = "[";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          if (/^[^\]]/.test(input.charAt(pos))) {
            result2 = input.charAt(pos);
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[^\\]]");
            }
          }
          while (result2 !== null) {
            result1.push(result2);
            if (/^[^\]]/.test(input.charAt(pos))) {
              result2 = input.charAt(pos);
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("[^\\]]");
              }
            }
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 93) {
              result2 = "]";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"]\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, text) {
            return new Label(text.join(""));
          })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_operator() {
        var result0;
        
        if (/^[+|\-|*|\/|%]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[+|\\-|*|\\/|%]");
          }
        }
        return result0;
      }
      
      function parse_number() {
        var result0;
        
        result0 = parse_exponent();
        if (result0 === null) {
          result0 = parse_float();
          if (result0 === null) {
            result0 = parse_signedInteger();
          }
        }
        return result0;
      }
      
      function parse_integer() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (/^[0-9]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[0-9]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, digits) { 
            return parseInt(digits.join(""), 10);
          })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_signedInteger() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (/^[+|\-]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[+|\\-]");
          }
        }
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_integer();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, sign, int) {
           return sign == "-" ? -1 * int : int;
         })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_float() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_signedInteger();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 46) {
            result1 = ".";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result1 !== null) {
            if (/^[0-9]/.test(input.charAt(pos))) {
              result3 = input.charAt(pos);
              pos++;
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
            if (result3 !== null) {
              result2 = [];
              while (result3 !== null) {
                result2.push(result3);
                if (/^[0-9]/.test(input.charAt(pos))) {
                  result3 = input.charAt(pos);
                  pos++;
                } else {
                  result3 = null;
                  if (reportFailures === 0) {
                    matchFailed("[0-9]");
                  }
                }
              }
            } else {
              result2 = null;
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, int, dec) {
            //Check for -0 for stuff like -0.5 starting an expression.
            if(int === 0 && (1/int < 0)) return (-1.0 * parseFloat(int + "." + dec.join("")));
            else return parseFloat(int + "." + dec.join(""));
          })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_exponent() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_signedInteger();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 46) {
            result1 = ".";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_integer();
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 101) {
                result3 = "e";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"e\"");
                }
              }
              if (result3 !== null) {
                result4 = parse_signedInteger();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, int, dec, exp) { 
            return parseFloat(int + "." + dec + "e" + exp);
          })(pos0, result0[0], result0[2], result0[4]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_signedInteger();
          if (result0 !== null) {
            if (input.charCodeAt(pos) === 101) {
              result1 = "e";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"e\"");
              }
            }
            if (result1 !== null) {
              result2 = parse_signedInteger();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, int, exp) { 
              return parseFloat(int + "e" + exp);
            })(pos0, result0[0], result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse__() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result0 = [];
        if (/^[ |\t]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[ |\\t]");
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          if (/^[ |\t]/.test(input.charAt(pos))) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("[ |\\t]");
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, space) {
            return space.join("");
          })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse___() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (/^[ |\t]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[ |\\t]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[ |\t]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[ |\\t]");
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, space) {
            return space.join("");
          })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
        //Setup TYPE_* variables in the d20 namespace so that at runtime the same constants
        // are used by all scripts
        var d20 = (typeof window !== 'undefined' && window.d20 !== undefined) ? window.d20 : {};
        if (d20.dice == undefined) {
          d20.dice = d20.dice || {};
          d20.dice.TYPE_MATH_EXPR = "M";
          d20.dice.TYPE_ROLL_EXPR = "R";
          d20.dice.TYPE_GROUP_EXPR = "G";
          d20.dice.TYPE_LABEL = "L";
          d20.dice.TYPE_COMMENT = "C";
          d20.dice.TYPE_VALIDATED_ROLLS = "V";
        }
        
        function log(d) {
           console.log(d);
        }
        
        /**
         * Creates a new math expression
         * 
         * @param expr Base expression, defaults to ""
         */
        function MathExpression(expr) {
           this.type = d20.dice.TYPE_MATH_EXPR;
           this.expr = (expr != undefined ? expr : "");
        };
        
        /**
         * Creates a new roll expression
         * 
         * @param dice Number of dice to roll
         * @param sides Number of sides on the dice
         */
        function RollExpression(dice, sides) {
          this.type = d20.dice.TYPE_ROLL_EXPR;
          this.dice = dice;
          this.sides = sides;
          this.mods = {};
        };
      
        /**
         * Creates a new fate roll expression
         */
        function FateRollExpression(dice, table) {
          this.type = d20.dice.TYPE_ROLL_EXPR;
          this.dice = dice;
          this.fate = true;
          this.mods = {};
        };
      
        /**
         * Creates a new table roll expression
         */
        function TableRollExpression(dice, table) {
          this.type = d20.dice.TYPE_ROLL_EXPR;
          this.dice = dice;
          this.table = table;
          this.mods = {};
        };
      
        /**
         * Creates a new group expression
         * 
         * @param rolls The array of rolls that are members of the group
         */
        function GroupExpression(rolls, mods) {
          this.type = d20.dice.TYPE_GROUP_EXPR;
          this.rolls = rolls;
          this.mods = (mods || {});
        }
      
        /**
         * Creates a new label
         * 
         * @param text content of the label
         */
        function Label(text) {
          this.type = d20.dice.TYPE_LABEL;
          this.text = text;
        }
      
        /**
         * Creates a new comment
         * 
         * @param text content of the comment
         */
        function Comment(text) {
          this.type = d20.dice.TYPE_COMMENT;
          this.text = text;
        }
        
        /**
         * Merge two expressions or arrays of expressions. For both arguments strings,
         * single expressions, and arrays of expressions are all valid.
         * 
         * String arguments are converted into MathExpressions
         * Adjacent MathExpressions are merged into a single MathExpression
         * 
         * @returns array of expressions
         */
        function mergeExpressions(left, right) {
           //If left is a string convert to MathExpression
           if (typeof left == "string") {
              if (left.length == 0) {
                return right;
              }
              left = new MathExpression(left);
           }
           //If right is a string convert to MathExpression
           if (typeof right == "string") {
              if (right.length == 0) {
                return left;
              }
              right = new MathExpression(right);
           }
      
           //If both left and right are arrays merge into a single array
           if (Array.isArray(left) && Array.isArray(right)) {
             //If end of left and start of right are both math expressions
             if (left[left.length-1].type == d20.dice.TYPE_MATH_EXPR && right[0].type == d20.dice.TYPE_MATH_EXPR) {
               //Remove the end of the left
               var leftMath = left.pop();
               //Merge the end of the left to the start of the right
               right[0].expr = leftMath.expr + right[0].expr;
             }
             
             //Merge the two arrays
             return left.concat(right);
           }
           //Left is an array, right is an object
           else if (Array.isArray(left)) {
             //End of the left and right are math expressions, append right onto the end of left
             if (left[left.length-1].type == d20.dice.TYPE_MATH_EXPR && right.type == d20.dice.TYPE_MATH_EXPR) {
               left[left.length-1].expr += right.expr;
             }
             //End of the left is not a math expression, append right to the left array
             else {
               left.push(right);
             }
             
             return left;
           }
           //Right is an array, left is an object
           else if (Array.isArray(right)) {
             //Start of the right and left are math expressions, prepend left onto the start of right
             if (right[0].type == d20.dice.TYPE_MATH_EXPR && left.type == d20.dice.TYPE_MATH_EXPR) {
               right[0].expr = left.expr + right[0].expr;
             }
             //Start of the right is not a math expression, prepend left to the right array
             else {
               right.unshift(left);
             }
             
             return right;
           }
           //If both left and right are single math expressions append right to left
           //and return left
           else if (left.type == d20.dice.TYPE_MATH_EXPR && right.type == d20.dice.TYPE_MATH_EXPR) {
             left.expr += right.expr;
             return left;
           }
           
           //Left and Right are not arrays
           return [left, right];
        }
        
        /**
         * Process roll/group mods into a single object
         * @returns The complete object
         */
        function processMods(head, tail) {
          var result = head;
          if (tail.length > 0) {
            for (var attrname in tail[0]) {
              if (result[attrname] != undefined) {
                throw {message:"'" + attrname + "' roll modifier can only be specified once"};
              }
              result[attrname] = tail[0][attrname];
            }
          }
          return result;
        };
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();

d20.dice_formatter = {};
d20ext["dice_formatter"] = d20.dice_formatter;

(function() {

	var showCritAnimation = function() {

		return;

		if(d20.textchat.chatstartingup) return;

		$("#critanimation").addClass("critted");
		$("#maincanvas").addClass("critted");
		setTimeout(function() {
			$("#critanimation").removeClass("critted");
			$("#maincanvas").removeClass("critted");
		}, 2000);
	}
	
	var formatRolls = function(rolls) {

		var formula = "";

		for(var i=0; i < rolls.length; i++) {

			if(rolls[i].type === d20.dice.TYPE_GROUP_EXPR) {
				formula += "{<div class='parsegroup'>"
				for(var gi=0; gi < rolls[i].rolls.length; gi++) {
					formula += "<div class='parsegroupitem ";
					if(rolls[i].results && rolls[i].results[gi].d) {
						formula += "dropped";
					}
					formula += "'>";
					formula += formatRolls(rolls[i].rolls[gi]);
					if(gi + 1 < rolls[i].rolls.length) {
						formula += " + "
					}
					formula += "</div>";
				}
				formula += "</div>}";
			}

			if(rolls[i].type === d20.dice.TYPE_ROLL_EXPR) {
				formula += "<div class='dicegrouping' data-groupindex='"+i+"' "

				//Is the next one a label? if so add a title
				if(rolls[i+1] && rolls[i+1].type == d20.dice.TYPE_LABEL) {
					formula += "title='"+rolls[i+1].text.replace(/'/g, "&apos;")+"'"
				}

				formula += ">";
				formula += "(";
				for (var r = 0; r < rolls[i].results.length; r++) {
					formula += "<div data-origindex='"+r+"' class='diceroll "

					if(rolls[i].results.length > 50) {
						formula += "withouticons ";
					}

					if(rolls[i].fate) {
						formula += "d6";
					}
					else if(!rolls[i].table) {
						formula += "d" + rolls[i].sides;
					}

					if(rolls[i].results[r].d === true) {
						formula += " dropped ";
					}

					var didCrit = false;
					var didFumble = false;
					var didMatch = false;

					if(rolls[i].mods && rolls[i].mods.customCrit) {
						//Check each to see if we critted.
						_.each(rolls[i].mods.customCrit, function(csdef) {
							if(csdef.comp === "<=") {
								if(rolls[i].results[r].v <= csdef.point) didCrit = true;
							}
							else if(csdef.comp === ">=") {
								if(rolls[i].results[r].v >= csdef.point) didCrit = true;
							}
							else if(csdef.comp === "==") {
								if(rolls[i].results[r].v === csdef.point) didCrit = true;
							}
						});
					}
					else if(rolls[i].results[r].v === rolls[i].sides) {
						didCrit = true;
					}

					if(didCrit) {
						formula += " critsuccess ";
						showCritAnimation();
					}

					if(rolls[i].mods && rolls[i].mods.customFumble) {
						//Check each to see if we critted.
						_.each(rolls[i].mods.customFumble, function(csdef) {
							if(csdef.comp === "<=") {
								if(rolls[i].results[r].v <= csdef.point) didFumble = true;
							}
							else if(csdef.comp === ">=") {
								if(rolls[i].results[r].v >= csdef.point) didFumble = true;
							}
							else if(csdef.comp === "==") {
								if(rolls[i].results[r].v === csdef.point) didFumble = true;
							}
						});
					}
					else if(rolls[i].results[r].v === 1 && rolls[i].fate !== true) {
						didFumble = true;
					}

					if(didFumble) {
						formula += " critfail ";
					}

					if(rolls[i].mods && rolls[i].mods.match && rolls[i].mods.match.matches[rolls[i].results[r].v]) {
						didMatch = true;
					}

					if(didMatch) {
						formula += " match-" + rolls[i].mods.match.matches[rolls[i].results[r].v] + "";
					}

					formula += "'>";

					if(didMatch) {
						formula += "<div class='matchbar' style='border-color:" + rolls[i].mods.match.matches[rolls[i].results[r].v] + "'></div>";
					}

					formula += "<div class='dicon'><div class='didroll'>"; 
					if (rolls[i].fate === true) {
						switch(rolls[i].results[r].v) {
							case 1: 
								formula += "+";
								break;
							case 0: 
								formula += "0";
								break;
							case -1:
								formula += "-";
								break;
						}
					}
					else if(rolls[i].results[r].tableItem) {
						if(rolls[i].results[r].tableItem.avatar && rolls[i].results[r].tableItem.avatar !== "") {
							const avatar = rolls[i].results[r].tableItem.avatar.replace("/med.webm", "/thumb.webm");
							const title = d20ext.utils.strip_tags(rolls[i].results[r].tableItem.name).replace(/'/g, "&apos;");
							
							formula += d20.utils.isVideo(avatar) ?
								`<video src="${avatar}" title="${title}" muted autoplay loop />` :
								`<img src="${avatar}" title="${title}" />`;
						}
						else {
							formula += d20ext.utils.strip_tags(rolls[i].results[r].tableItem.name);
						}
					}
					else {
						formula += rolls[i].results[r].v;
					}

					formula += "</div><div class='backing'></div></div>";

					if (rolls[i].fate !== true && r + 1 < rolls[i].results.length) {
						formula += "+";
					}

					formula += "</div>";
				}
				formula += ")";
				formula += "</div>";
			}

			else if(rolls[i].type === d20.dice.TYPE_MATH_EXPR) {
				formula += rolls[i].expr;
			}

		}

		return formula;
	};

	var textOnlyFormatRolls = function(rolls) {

		var formula = "";

		for(var i=0; i < rolls.length; i++) {

			if(rolls[i].type === d20.dice.TYPE_GROUP_EXPR) {
				formula += "{"
				for(var gi=0; gi < rolls[i].rolls.length; gi++) {
					formula += textOnlyFormatRolls(rolls[i].rolls[gi]);
					if(gi + 1 < rolls[i].rolls.length) {
						formula += "+"
					}
				}
				formula += "}";
			}

			if(rolls[i].type === d20.dice.TYPE_ROLL_EXPR) {
				var rl = rolls[i].results !== undefined ? rolls[i].results.length : 0;
				formula += "(";
				for (var r = 0; r < rl; r++) {
					if (rolls[i].fate === true) {
						switch(rolls[i].results[r].v) {
							case 1: 
								formula += "+";
								break;
							case 0: 
								formula += "0";
								break;
							case -1:
								formula += "-";
								break;
						}
					}
					else if(rolls[i].results[r].tableItem) {
						formula += d20ext.utils.strip_tags(rolls[i].results[r].tableItem.name);
					}
					else {
						formula += rolls[i].results[r].v;
					}

					if (rolls[i].fate !== true && r + 1 < rolls[i].results.length) {
						formula += "+";
					}
				}
				formula += ")";
			}

			else if(rolls[i].type === d20.dice.TYPE_MATH_EXPR) {
				formula += rolls[i].expr;
			}

		}

		return formula;

	};

	var basicHTMLFormatRolls = function(rolls) {

		if(!rolls) return;

		var formula = "";

		for(var i=0; i < rolls.length; i++) {
			if(rolls[i].type === d20.dice.TYPE_GROUP_EXPR) {
				formula += "{"
				for(var gi=0; gi < rolls[i].rolls.length; gi++) {
					formula += basicHTMLFormatRolls(rolls[i].rolls[gi]);
					if(gi + 1 < rolls[i].rolls.length) {
						formula += "+"
					}
				}
				formula += "}";
			}

			if(rolls[i].type === d20.dice.TYPE_ROLL_EXPR) {
				var rl = rolls[i].results !== undefined ? rolls[i].results.length : 0;
				var matches = rolls[i].mods && rolls[i].mods.match && rolls[i].mods.match.matches ? rolls[i].mods.match.matches : [];
				formula += "(";
				for (var r = 0; r < rl; r++) {

					formula += "<span class='basicdiceroll";

					if(rolls[i].results[r].d) {
						formula += " dropped";
					}
					else {
						var didCrit = false;
						var didFumble = false;
						if(rolls[i].mods && rolls[i].mods.customCrit) {
							//Check each to see if we critted.
							_.each(rolls[i].mods.customCrit, function(csdef) {
								if(csdef.comp === "<=") {
									if(rolls[i].results[r].v <= csdef.point) didCrit = true;
								}
								else if(csdef.comp === ">=") {
									if(rolls[i].results[r].v >= csdef.point) didCrit = true;
								}
								else if(csdef.comp === "==") {
									if(rolls[i].results[r].v === csdef.point) didCrit = true;
								}
							});
						}
						else if(rolls[i].results[r].v === rolls[i].sides) {
							didCrit = true;
						}

						if(didCrit) {
							formula += " critsuccess ";
						}

						if(rolls[i].mods && rolls[i].mods.customFumble) {
							//Check each to see if we critted.
							_.each(rolls[i].mods.customFumble, function(csdef) {
								if(csdef.comp === "<=") {
									if(rolls[i].results[r].v <= csdef.point) didFumble = true;
								}
								else if(csdef.comp === ">=") {
									if(rolls[i].results[r].v >= csdef.point) didFumble = true;
								}
								else if(csdef.comp === "==") {
									if(rolls[i].results[r].v === csdef.point) didFumble = true;
								}
							});
						}
						else if(rolls[i].results[r].v === 1 && rolls[i].fate !== true) {
							didFumble = true;
						}

						if(didFumble) {
							formula += " critfail ";
						}
					}

					if(matches != [] && matches[rolls[i].results[r].v]) {
						formula += "' style='color: " + matches[rolls[i].results[r].v] + "'";
					}

					formula += "'>";

					if (rolls[i].fate === true) {
						switch(rolls[i].results[r].v) {
							case 1: 
								formula += "+";
								break;
							case 0: 
								formula += "0";
								break;
							case -1:
								formula += "-";
								break;
						}
					}
					else if(rolls[i].results[r].tableItem) {
						formula += d20ext.utils.strip_tags(rolls[i].results[r].tableItem.name);
					}
					else {
						formula += rolls[i].results[r].v;
					}

					formula += "</span>";

					if (rolls[i].fate !== true && r + 1 < rolls[i].results.length) {
						formula += "+";
					}
				}
				formula += ")";
			}

			else if(rolls[i].type === d20.dice.TYPE_MATH_EXPR) {
				formula += rolls[i].expr;
			}

		}

		return formula;

	};

	d20.dice_formatter.basicHTMLFormatRolls = basicHTMLFormatRolls;

	d20.dice_formatter.checkForCrits = function(rolls, crittype) {

		if(!rolls) return false;

		var didCrit = false;
		var didFumble = false;

		for(var i=0; i < rolls.length; i++) {

			if(rolls[i].type === d20.dice.TYPE_GROUP_EXPR) {
				for(var gi=0; gi < rolls[i].rolls.length; gi++) {
					if(d20.dice_formatter.checkForCrits(rolls[i].rolls[gi], crittype) === true) {
						if(crittype === "crit") 
							didCrit = true;
						else 
							didFumble = true;
					}
				}
			}

			if(rolls[i].type === d20.dice.TYPE_ROLL_EXPR) {
				var rl = rolls[i].results !== undefined ? rolls[i].results.length : 0;
				for (var r = 0; r < rl; r++) {
					// Skip dropped dice so they can't trigger WasCrit or WasFumble
					if(rolls[i].results[r].d === true) continue;

					if(rolls[i].mods && rolls[i].mods.customCrit) {
						//Check each to see if we critted.
						_.each(rolls[i].mods.customCrit, function(csdef) {
							if(csdef.comp === "<=") {
								if(rolls[i].results[r].v <= csdef.point) didCrit = true;
							}
							else if(csdef.comp === ">=") {
								if(rolls[i].results[r].v >= csdef.point) didCrit = true;
							}
							else if(csdef.comp === "==") {
								if(rolls[i].results[r].v === csdef.point) didCrit = true;
							}
						});
					}
					else if(rolls[i].results[r].v === rolls[i].sides) {
						didCrit = true;
					}

					if(rolls[i].mods && rolls[i].mods.customFumble) {
						//Check each to see if we critted.
						_.each(rolls[i].mods.customFumble, function(csdef) {
							if(csdef.comp === "<=") {
								if(rolls[i].results[r].v <= csdef.point) didFumble = true;
							}
							else if(csdef.comp === ">=") {
								if(rolls[i].results[r].v >= csdef.point) didFumble = true;
							}
							else if(csdef.comp === "==") {
								if(rolls[i].results[r].v === csdef.point) didFumble = true;
							}
						});
					}
					else if(rolls[i].results[r].v === 1 && rolls[i].fate !== true) {
						didFumble = true;
					}
				}
			}
		}

		return (crittype === "crit" ? didCrit : didFumble);
	}

	d20.dice_formatter.getHtmlForResult = function(resultObj) {
		var formula = formatRolls(resultObj.rolls);
		var total = resultObj.total;

		if(resultObj.resultType === d20.dice.ROLL_TYPE_SUCCESS) {
			total = total === 1 ? total + " Success" : total + " Successes";
		}
		else if(resultObj.resultType === d20.dice.ROLL_TYPE_MATCH) {
			total = total === 1 ? total + " Match" : total + " Matches";
		}

		return {
			formula: formula,
			total: total
		}
	};

	d20.dice_formatter.replaceInlineRolls = function(textcontent, op, allowedTags) {
		// textcontent = d20.utils.strip_tags(textcontent.replace("<","&lt;"), allowedTags);
		textcontent = d20.utils.strip_tags(textcontent, allowedTags);
		if(!op.inlinerolls) return textcontent;
		textcontent = textcontent.replace(/\$\[\[[0-9]+(\.computed)?\]\]/g, function(inlinematch) {
			const strippedMatch = inlinematch.replace(/[\$\[\[\]\]]/g, '');
			// Check whether we're looking for the computed value
			const computed = strippedMatch.substr(-9) === '.computed' ? true : false;
			var inlinerollindex = strippedMatch.split('.')[0];
			var inlineroll = op.inlinerolls[parseInt(inlinerollindex, 10)];
			if(!inlineroll || !inlineroll.results) {
				return "INVALID INLINE ROLL!";
			}

			inlineroll.expression = inlineroll.expression.replace("<","&lt;");
			var mytitle = "Rolling " + d20.utils.strip_tags(inlineroll.expression, allowedTags) + " = ";

			if(inlineroll.signature && d20.textchat.verifyRoll(inlineroll.rollid, inlineroll.results, inlineroll.signature)) {
				mytitle = "<img src='/images/quantumrollwhite.png' class='inlineqroll'> " + mytitle;
			}

			mytitle += basicHTMLFormatRolls(inlineroll.results.rolls);

			// Use the computed result if requested
			// Note that if a computed value isn't present, the total will be used
			var mytotal = computed && inlineroll.computed !== undefined ? inlineroll.computed :inlineroll.results.total;
			try {
				if(mytotal == 0 && inlineroll.results.rolls[0].results[0].tableItem) mytotal = d20ext.utils.strip_tags(inlineroll.results.rolls[0].results[0].tableItem.name);
			}
			catch(e) {
				//discard
			}

			var myhtml = "<span class='inlinerollresult showtip tipsy-n-right";
			var hascrit = mytitle.indexOf("critsuccess") !== -1;
			var hasfail = mytitle.indexOf("critfail") !== -1;

			if(hascrit && hasfail) {
				myhtml += " importantroll";
			}
			else if(hascrit) {
				myhtml += " fullcrit";
			}
			else if(hasfail) {
				myhtml += " fullfail";
			}

			myhtml += "' title='"+mytitle.replace(/'/g, "&quot;")+"'>" + mytotal + "</span>";

			return myhtml;

		});

		return textcontent;
	};

	/**
	* Associate format markers with CSS classes
	*/
	var rollFormats = {
		"@": "critsuccess",
		"#": "critfail",
		"_": "dropped"
	};

	/**
	* Determines all nessted formatting rules 
	*/
	var getAllFormats = function(roll, formats) {
		for (var formatType in rollFormats) {
			var pattern = new RegExp("\\{" + formatType + "(.+?)" + formatType + "\\}", "g");
			var match;
			if ((match = pattern.exec(roll)) != null) {
				formats.push( rollFormats[formatType] );
				return getAllFormats(match[1], formats);
			}
		}

		return roll;
	}

	/**
	* Formats a dice roll string into HTML
	*/
	d20.dice_formatter.oldformat = function(rollResult) {
		if(rollResult === undefined) {
			return "";
		}
		return rollResult.replace(/\{([@#_])(.+?)\1\}/g, function(roll, formatType, value) {
			var formats = [ rollFormats[formatType] ];
			var value = getAllFormats(value, formats);

			return "<span class='" + formats.sort().join(" ") + "'>" + value + "</span>";
		});
	}
	
})();

d20.dice_engine = function(seed) {
	d20.dice = d20.dice || {};
	d20.dice.TYPE_MATH_EXPR = "M";
	d20.dice.TYPE_ROLL_EXPR = "R";
	d20.dice.TYPE_GROUP_EXPR = "G";
	d20.dice.TYPE_LABEL = "L";
	d20.dice.TYPE_COMMENT = "C";
	d20.dice.TYPE_VALIDATED_ROLLS = "V";
	d20.dice.ROLL_TYPE_MATCH = "match";
	d20.dice.ROLL_TYPE_SUCCESS = "success";
	d20.dice.ROLL_TYPE_TABLE = "table";
	d20.dice.ROLL_TYPE_SUM = "sum";
	d20.dice.MATCH_COLORS = ["#ee0086","#ff9c00","#688de8","#a6f900","#a909e1","#ff6a00","#07afde","#eefe00"];

	if (d20.getTableElementCount == undefined) {
		d20.getTableElementCount = function(name) {
			log("Using fallback getTableElementCount(" + name + ")");
			return name.length;
		};
		d20.getTableElementValue = function(name, index) {
			log("Using fallback getTableElementValue(" + name + ", " + index + ")");
			return parseInt(name, 10) || 0;
		};
	}

	var MAX_NUM_ROLLS = 999;
	var MAX_ROLL = 9999999;
	var recentRolls = [];

	if (seed == undefined) {
		Math.seedrandom(window.RANDOM_ENTROPY, true);
	}
	else {
		Math.seedrandom(seed);
	}

	this.random = Math.randomInt;

	var othis = this;

	/**
	 * Utility class that triggers the execution of a callback after
	 * a specified number of tasks have signalled completion by calling
	 * taskComplete();
	 *
	 * @param taskCount Number of tasks that must complete before completionCallback is executed
	 * @param completionCallback The callback to execute once taskCount tasks have been completed
	 */
	function TaskCompletionCallback(taskCount, completionCallback, name) {
		var calls = 0;
		var called = false;

		this.taskComplete = function() {
			if (calls == taskCount) {
				throw "All " + calls + " tasks have already been completed for: " + name;
			}
			calls++;
			//log(name + ": " + calls);
			if (calls == taskCount) {
				called = true;
				completionCallback();
			}
		};

		this.verify = function() {
			if (calls == taskCount && !called) {
				completionCallback();
			}
		};
	};

	/**
	 * The result of rolling a die
	 */
	function RollResult(i) {
		this.i = i;
		this.v = 0;
	}

	/**
	 * The result of rolling a group
	 */
	function GroupResult(v) {
		this.v = v;
	}

	/**
	 * The result of a parsed roll expression that has also been validated
	 */
	function ValidatedRollExpression(rolls, resultType) {
		this.type = d20.dice.TYPE_VALIDATED_ROLLS;
		this.rolls = rolls;
		this.resultType = resultType;
	};

	/**
	 * Builds an eval'able expression from the roll results. Handles groups of expressions and
	 * groups with no entries as well as success/failure comparisons.
	 */
	function ExpressionBuilder() {
		var expression = "";
		var groupMemeberCount = undefined;
		var prevResults;

		var verifyInGroup = function() {
			if (groupMemeberCount == undefined) {
				throw "Not currently in a group expression: '" + expression + "'";
			}
		};

		this.addMathExpr = function(expr) {
			expression += expr;
		};

		this.startGroup = function() {
			expression += "(";
			groupMemeberCount = 0;
			prevResults = []; // FOR MATCH TOTAL ROLLS ONLY
		};

		this.addGroupValue = function(value) {
			verifyInGroup();
			if (groupMemeberCount > 0) {
				expression += "+";
			}
			expression += value;
			groupMemeberCount++;
		};

		this.addGroupSuccess = function(value, cp) {
			this.addGroupValue("(" + value + cp.comp + cp.point + "?1:0)");
		};

		this.addGroupFailure = function(value, cp) {
			this.addGroupValue("(" + value + cp.comp + cp.point + "?-1:0)");
		};

		this.addGroupMatch = function(value, cp) {
			var comp = cp.comp ? cp.comp : ">=";
			var point = cp.point ? cp.point : "0";
			prevResults.push(value);
			var match_obj = {};
			for (var i = 0; i < prevResults.length; i++) {
				var num = prevResults[i];
				match_obj[num] = match_obj[num] ? match_obj[num] + 1 : 1;
			}
			var matches = match_obj[value];
			if(matches === cp.threshold) {
				this.addGroupValue("(" + value + comp + point + "?1:0)");
			}
		};

		this.endGroup = function() {
			verifyInGroup();
			if (groupMemeberCount == 0) {
				expression += "0";
			}
			expression += ")";
			groupMemeberCount = undefined;
			prevResults = [];
		};

		this.eval = function() {
			log(expression);
			var result;
			var thisexp = expression;
			(function() {

				"use strict";

				var floor = Math.floor;
				var ceil = Math.ceil;
				var round = Math.round;
				var max = Math.max;
				var min = Math.min;
				var abs = Math.abs;

				try {
					result = eval(thisexp);
				}
				catch (e) {
					result = 0;
				}
			})();
			return result;
		};
	};

	/**
	 * log a message, might be disabled, see logerr for parameter details.
	 */
	var log = function(m) {
		return; // comment out this line to disable logging
		logerr(m);
	};

	/**
	 * Log a message, will never be disabled
	 *
	 * @param m
	 *          the message to log, if m is a function it will be evaluated before
	 *          logging
	 */
	var logerr = function(m) {
		if (_.isFunction(m)) {
			m = m();
		}
	};

	var fallbackErrorHandler = function(e) {
		logerr(e);
		throw e;
	};

	/**
	 * Formats a diceRoll object back into a roll expression
	 */
	var diceRollToString = function(roll) {
		var rollStr = roll.dice + "d" + roll.sides;

		if (roll.mods.compounding) {
			rollStr += "!!" + comparePointToString(roll.mods.compounding);
		}
		if (roll.mods.penetrating) {
			rollStr += "!p" + comparePointToString(roll.mods.penetrating);
		}
		if (roll.mods.exploding) {
			rollStr += "!" + comparePointToString(roll.mods.exploding);
		}
		if (roll.mods.keep) {
			rollStr += "k";
			if (roll.mods.keep.end != "h") {
				rollStr += roll.mods.keep.end;
			}
			rollStr += roll.mods.keep.count;
		}
		if (roll.mods.drop) {
			rollStr += "k";
			if (roll.mods.drop.end != "l") {
				rollStr += roll.mods.drop.end;
			}
			rollStr += roll.mods.drop.count;
		}
		if (roll.mods.reroll) {
			roll.mods.reroll.forEach(function(cp) {
				rollStr += "r" + comparePointToString(cp);
			});
		}
		if (roll.mods.sort) {
			rollStr += "s" + roll.mods.sort.order;
		}
		if (roll.mods.success) {
			rollStr += comparePointToString(roll.mods.success, true);
		}
		if (roll.mods.failure) {
			rollStr += "f" + comparePointToString(roll.mods.failure, true);
		}

		return rollStr;
	};
	var comparePointToString = function(cp, explicitEquals) {
		var cpStr = "";
		if (cp.point) {
			if (cp.comp != "==" || explicitEquals) {
				cpStr += cp.comp.charAt(0);
			}
			cpStr += cp.point;
		}
		return cpStr;
	};

	/**
	 * Validates that all of the rolls in the expression have sane combinations and limits in place
	 *
	 * @return The number of actual rolls in the array of expression objects
	 */
	var validateParseResult = function(rolls) {
		var resultType = undefined;

		// Per level track success/sum state
		for (var i = 0; i < rolls.length; i++) {
			if (rolls[i].type == d20.dice.TYPE_ROLL_EXPR || rolls[i].type == d20.dice.TYPE_GROUP_EXPR) {
				var rollType = getRollType(rolls[i]);
				if (resultType == undefined) {
					resultType = rollType;
				}
				else if (resultType != rollType) {
					throw "Cannot mix " + resultType + " and " + rollType + " rolls in a single roll expression";
				}
			}

			if (rolls[i].type == d20.dice.TYPE_ROLL_EXPR) {
				//Setup sides for fate rolls
				if (rolls[i].fate) {
					rolls[i].sides = 3;
				}
				//Setup sides for table rolls
				else if (rolls[i].table != undefined) {
					rolls[i].sides = d20.getTableElementCount(rolls[i].table);
				}

				// Enforce that fate dice don't support compounding
				if (rolls[i].fate && rolls[i].mods.compounding != undefined) {
					throw "Compounding FATE dice are not legal, try ! instead of !! for exploding FATE dice";
				}

				//Make sure that we don't try to do an exploding d1 dice. /sigh
				if (rolls[i].mods && rolls[i].mods.exploding != undefined && rolls[i].sides < 2) {
					throw "You must roll a d2 or higher to roll exploding dice.";
				}

				// Add sanity bounds checks
				rolls[i].dice = Math.max(Math.min(rolls[i].dice, MAX_NUM_ROLLS), 0);
				rolls[i].sides = Math.max(Math.min(rolls[i].sides, MAX_ROLL), 0);
			}

			if (rolls[i].type == d20.dice.TYPE_GROUP_EXPR) {

				//For groups with one sub-roll doign a sucess check verify that the sub-roll only contains one roll expression and no group expressions
				if (rolls[i].rolls.length == 1 && resultType == d20.dice.ROLL_TYPE_SUCCESS) {
					var foundRoll = false;
					for (var r = 0; r < rolls[i].rolls[0].length; r++) {
						if (rolls[i].rolls[0][r].type == d20.dice.TYPE_ROLL_EXPR) {
							if (foundRoll) {
								throw "Only one roll expression is allowed in a single sub-roll expression success check";
							}
							foundRoll = true;
						}
						else if (rolls[i].rolls[0][r].type == d20.dice.TYPE_GROUP_EXPR) {
							throw rolls[i].rolls[0][r].type + " expression is not supported in a single sub-roll expression success check";
						}
					}
				}

				// Recurse on grouped rolls
				var groupResultType = undefined;
				for (var g = 0; g < rolls[i].rolls.length; g++) {
					var subGroupResultType = validateParseResult(rolls[i].rolls[g]);
					if (groupResultType == undefined) {
						groupResultType = subGroupResultType;
					}
					else if (groupResultType != subGroupResultType) {
						throw "Cannot mix " + groupResultType + " and " + subGroupResultType + " rolls in a  roll group";
					}
				}
				rolls[i].resultType = groupResultType;
			}
		}

		if (resultType == undefined) {

			//Math-only rolls.
			if (rolls[0].type === d20.dice.TYPE_MATH_EXPR) {
				return d20.dice.TYPE_MATH_EXPR;
			}

			throw "Could not determine result type of: " + JSON.stringify(rolls);
		}
		return resultType;
	};

	var getRollType = function(diceRoll) {
		if (diceRoll.mods && diceRoll.mods.match !== undefined && diceRoll.mods.match.total !== undefined) {
			return d20.dice.ROLL_TYPE_MATCH;
		}
		else if (diceRoll.mods && diceRoll.mods.success !== undefined) {
			return d20.dice.ROLL_TYPE_SUCCESS;
		}
		else if (diceRoll.sides != undefined && diceRoll.sides.type == d20.dice.TYPE_LABEL) {
			return d20.dice.ROLL_TYPE_TABLE;
		}
		else {
			return d20.dice.ROLL_TYPE_SUM;
		}
	};

	/**
	 * Parse the dice formula string using the dice grammar and validate
	 * the result
	 *
	 * @param formula The parsed roll object model
	 */
	var parseRollString = function(rollString) {
		log(function() { return "E parseRollString: " + rollString; });

		// Use Parser Grammar to parse the roll expression
		var rolls = d20.DicePEG.parse(rollString);
		log(rolls);

		var resultType = validateParseResult(rolls);

		var vre = new ValidatedRollExpression(rolls, resultType);
		log(vre);
		log(JSON.stringify(vre));
		log(function() { return "L parseRollString: " + vre.rolls.length + " expressions from: " + rollString; });

		return vre;
	};

	/**
	 * Initiate all rolls in the parse tree
	 *
	 * @param rolls An array of expresion objects
	 * @param roll rollsCompleteCallback Callback to execute when each entry in the array is complete
	 */
	var initiateRolls = function(rolls, resultType, rollsCompleteCallback) {
		for (var i = 0; i < rolls.length; i++) {
			if (rolls[i].type == d20.dice.TYPE_ROLL_EXPR) {
				doRolls(rolls[i], rollsCompleteCallback);
			}
			else if (rolls[i].type == d20.dice.TYPE_GROUP_EXPR) {
				initiateGroupRolls(rolls[i], resultType, rollsCompleteCallback);
			}
			else {
				rollsCompleteCallback();
			}
		}
	};
	/**
	 * Initiates rolls for a group, needed so the correct scoping of groupCompleteCallback
	 * is used.
	 */
	var initiateGroupRolls = function(groupRoll, resultType, rollsCompleteCallback) {
		var groupCompleteCallback = new TaskCompletionCallback(groupRoll.rolls.length, function() {
			postProcessCompleteGroup(groupRoll, resultType);
			rollsCompleteCallback();
		}, "groupCompleteCallback");

		for (var g = 0; g < groupRoll.rolls.length; g++) {
			initiateSubGroupRolls(groupRoll.rolls[g], groupRoll.resultType, groupCompleteCallback);
		}
	};
	/**
	 * Initiates rolls for a subgroup, needed so the correct scoping of subGroupCompleteCallback
	 * is used.
	 */
	var initiateSubGroupRolls = function(subGroup, resultType, groupCompleteCallback) {
		var subGroupCompleteCallback = new TaskCompletionCallback(subGroup.length, function() {
			groupCompleteCallback.taskComplete();
		}, "subGroupCompleteCallback");

		initiateRolls(subGroup, resultType, function() {
			subGroupCompleteCallback.taskComplete();
		});
	};

	/**
	 * Fire off each roll required for the diceRoll using asyncRand.
	 */
	var doRolls = function(diceRoll, rollsCompleteCallback) {
		log(function() { return diceRollToString(diceRoll) + "\t - E doRolls"; });

		// Add arrays to track rolls to diceRoll
		diceRoll.results = [];

		// Setup the callback tracker for signaling when each roll is complete
		var taskCallback = new TaskCompletionCallback(diceRoll.dice, function() {
			diceRollCompleteCallback(diceRoll);
			rollsCompleteCallback();
		}, "rollCompleteCallback");

		var rollCompleteCallback = function() {
			taskCallback.taskComplete();
		};

		// Execute each roll for the dice
		for (var r = 0; r < diceRoll.dice; r++) {
			rollDie(r, diceRoll, rollCompleteCallback);
		}

		//Handling for the case where diceRoll.dice == 0, ensures the callback is executed no matter what
		taskCallback.verify();

		log(function() { return diceRollToString(diceRoll) + "\t - L doRolls"; });
	};

	/**
	 * Processes modifiers on the a single dice roll that are applied after all dice within
	 * the roll have completed. This includes keep, drop, and sort.
	 */
	var diceRollCompleteCallback = function(diceRoll) {
		log(function() { return diceRollToString(diceRoll) + "\t - E diceRollCompleteCallback"; });

		//First order rolls by index and the drop flag to have an intuitive "natural" ordering of dice
		diceRoll.results.sort(function(a, b) {
			var d = (a.i - b.i);
			if (d != 0 || a.d == b.d) {
				return d;
			}
			if (a.d) {
				return -1;
			}
			return 1;
		});

		//Clean up data model by removing roll index, it isn't needed after this point (right?)
		diceRoll.results.forEach(function(r) {
			delete r.i;
		});

		if (diceRoll.mods && diceRoll.mods.keep != undefined) {
			var order = (diceRoll.mods.keep.end == "l" ? "a" : "d");
			var sortedResults = sortRolls(diceRoll.results, order);

			keepRolls(sortedResults, diceRoll.mods.keep.count);
		}
		if (diceRoll.mods && diceRoll.mods.drop != undefined) {
			var order = (diceRoll.mods.drop.end == "l" ? "a" : "d");
			var sortedResults = sortRolls(diceRoll.results, order);

			dropRolls(sortedResults, diceRoll.mods.drop.count);
		}
		if (diceRoll.mods && diceRoll.mods.sort != undefined) {
			diceRoll.results = sortRolls(diceRoll.results, diceRoll.mods.sort.order);
		}

		log(function() { return diceRollToString(diceRoll) + "\t - L diceRollCompleteCallback"; });
	};

	/**
	 * Process modifiers on a group of rolls that are applied after all of the group expressions
	 * within the group.
	 */
	var postProcessCompleteGroup = function(groupRoll, resultType) {
		log(function() { return "E postProcessCompleteGroup(" + resultType + ")"; });

		if (groupRoll.mods && groupRoll.mods.keep != undefined && groupRoll.rolls.length == 1) {
			//apply keep to the total set of rolls within the group
			var order = (groupRoll.mods.keep.end == "l" ? "a" : "d");

			var allRolls = buildSubGroupRollsArray(groupRoll.rolls[0]);

			allRolls = sortRolls(allRolls, order);
			keepRolls(allRolls, groupRoll.mods.keep.count);

			cleanupSubGroupValues(groupRoll.rolls[0]);
		}
		if (groupRoll.mods && groupRoll.mods.drop != undefined && groupRoll.rolls.length == 1) {
			//apply drop to the total set of rolls within the group
			var order = (groupRoll.mods.drop.end == "l" ? "a" : "d");

			var allRolls = buildSubGroupRollsArray(groupRoll.rolls[0]);

			allRolls = sortRolls(allRolls, order);
			dropRolls(allRolls, groupRoll.mods.drop.count);

			cleanupSubGroupValues(groupRoll.rolls[0]);
		}

		//Total things up for the group, needed for subgroup keep/drop
		totalResult(groupRoll, resultType);

		if (groupRoll.mods && groupRoll.mods.keep != undefined && groupRoll.rolls.length > 1) {
			//apply keep to the subgroup results
			var order = (groupRoll.mods.keep.end == "l" ? "a" : "d");
			var groupResults = sortRolls(groupRoll.results, order);
			keepRolls(groupResults, groupRoll.mods.keep.count);
		}
		if (groupRoll.mods && groupRoll.mods.drop != undefined && groupRoll.rolls.length > 1) {
			//apply drop to the subgroup results
			var order = (groupRoll.mods.drop.end == "l" ? "a" : "d");
			var groupResults = sortRolls(groupRoll.results, order);
			dropRolls(groupResults, groupRoll.mods.drop.count);
		}

		log(function() { return "L postProcessCompleteGroup"; });
	};

	var buildSubGroupRollsArray = function(subGroups) {
		var allRolls = [];
		for (var g = 0; g < subGroups.length; g++) {
			if (subGroups[g].type == d20.dice.TYPE_ROLL_EXPR) {
				allRolls = allRolls.concat(subGroups[g].results);
			}
			else if (subGroups[g].type == d20.dice.TYPE_GROUP_EXPR) {
				subGroups[g].v = totalResult(subGroups[g], subGroups[g].resultType).eval();
				allRolls.push(subGroups[g]);
			}
		}
		return allRolls;
	};

	var cleanupSubGroupValues = function(subGroups) {
		subGroups.forEach(function(e) {
			if (e.type == d20.dice.TYPE_GROUP_EXPR) {
				delete e.v;
			}
		});
	};

	/**
	 * Keeps the first count rolls that are not already marked as dropped iterating through
	 * the array from 0 to N. After the count rolls are kept the remaining rolls are marked
	 * as dropped.
	 *
	 * @param rolls sorted array of rolls
	 * @param count number of rolls to keep
	 */
	var keepRolls = function(rolls, count) {
		var kept = 0;
		for (var i = 0; i < rolls.length; i++) {
			if (!rolls[i].d) {
				if (kept < count) {
					kept++;
				}
				else {
					rolls[i].d = true;
				}
			}
		}
	};

	/**
	 * Drops the first count rolls that are not already marked as dropped iterating through
	 * the array from 0 to N. After the count rolls are marked as dropped the method returns
	 *
	 * @param rolls sorted array of rolls
	 * @param count number of rolls to drop
	 */
	var dropRolls = function(rolls, count) {
		var dropped = 0;
		for (var i = 0; i < rolls.length && dropped < count; i++) {
			if (!rolls[i].d) {
				rolls[i].d = true;
				dropped++;
			}
		}
	};

	/**
	 * Return a of the rolls array sorted in the specified order
	 */
	var sortRolls = function(rolls, order) {
		var orderMod = (order == "d" ? -1 : 1);
		return rolls.slice(0).sort(function(a, b) {
			return (a.v - b.v) * orderMod;
		});
	};

	/**
	 * A simple random number generator, but we force it to be asynchronous so we
	 * can make sure that our dice engine can support an asynch generator. This
	 * way we can substitute in something like 3D Dice rolling or server-side
	 * "real" random numbers later on.
	 *
	 * @param sides
	 *          maximum integer to roll, returned value will be between 1 and
	 *          maxRoll inclusive
	 * @param randCallback
	 *          function called when the random number is generated, the random
	 *          number is provided as the only argument
	 */
	var asyncRand = function(sides, randCallback, no3d, rollid) {
		if (sides === 0) {
			setTimeout(function() {
				randCallback(0);
			}, 0);
		}

		//We no longer do local 3D rolls.

		else if (sides === 6 && d20.textchat && d20.textchat.egg_clickhole && !$("#lightly-overlay").is(":visible")) {
			var possibilities = [
				["2990", 1, 4],
				["2991", 1, 7],
				["2992", 1, 12],
				["2993", 2, 7],
				["2994", 2, 5],
				["2995", 2, 38],
				["2996", 2, 11],
				["2997", 3, 13],
				["2998", 3, 16],
				["2999", 3, 6],
				["3000", 3, 16],
				["3001", 4, 17],
				["3002", 4, 18],
				["3003", 4, 16],
				["3004", 5, 7],
				["3006", 5, 24],
				["3005", 5, 14],
				["3007", 5, 27],
				["3008", 6, 7],
				["3009", 6, 6],
				["3010", 6, 5],
				["3012", 6, 10]
			];

			var chosen = possibilities[othis.random(possibilities.length)];

			d20.textchat.sendShout({
				type: "playclickhole",
				playerid: window.currentPlayer.id,
				content: chosen,
				time: new Date().getTime()
			});

			if (window.fakeLightly) {
				window.fakeLightly("http://v.theonion.com/onionstudios/video/" + chosen[0] + "/640.mp4");
			}

			setTimeout(function() {
				randCallback(chosen[1]);
				$("#lightly-overlay").hide();
			}, (chosen[2] * 1000) + 2000);

		}
		else {
			setTimeout(function() {
				randCallback(othis.random(sides) + 1);
			}, 0);
		}
	};

	/**
	 * Compare a value to a ComparePoint, if defaultPoint is specified and no
	 * ComparePoint operator exists the comparison will be done as
	 * "value == defaultPoint"
	 */
	var compareToPoint = function(value, cp, defaultPoint) {
		if (cp.comp != undefined) {
			var cpFormula = value + cp.comp + cp.point;
			var cpResult = eval(cpFormula);
			return cpResult;
		}

		return value == defaultPoint;
	};

	/**
	 * Creates a new RollResult, pushes it onto the results array for the diceRoll
	 * and triggers asyncRand with a callback to individualRollCallback
	 *
	 * @param diceRoll The roll expression being executed
	 * @param rollCompleteCallback The callback to execute when the random number is generated
	 * @param rollModifierFunction An optional modifier function that can change the random number before it is passed to rollCompleteCallback
	 */
	var rollDie = function(rollIndex, diceRoll, rollCompleteCallback, extraRollCounter) {
		//Roll an additional die
		var rollResult = new RollResult(rollIndex);
		diceRoll.results.push(rollResult);

		//Have to do anon function call to so the correct rollResult reference is passed to the individualRollCallback
		(function(rr) {
			asyncRand(diceRoll.sides, function(rand) {
				individualRollCallback(diceRoll, rr, rand, rollCompleteCallback, extraRollCounter);
			}, (diceRoll.table !== undefined), diceRoll.rollid);
		}(rollResult));
	};

	/**
	 * Called by asyncRand for each new random roll, handles logic around immediately needed additional rolls
	 * for exploding, compounding, penetrating, and reroll modifiers
	 */
	var individualRollCallback = function(diceRoll, rollResult, rand, rollCompleteCallback, extraRollCounter) {
		extraRollCounter = (extraRollCounter || 0);
		log(function() { return diceRollToString(diceRoll) + "\t - E individualRollCallback(" + extraRollCounter + ") " + rand; });

		//Save the roll value, addition is used to handle modifiers like compounding that use the same
		//rollResult for multiple rolls
		//if(diceRoll.mods === undefined) diceRoll.mods = {};

		//If this is a rollable table roll, get the value for that table index.
		if (diceRoll.table !== undefined) {
			rollResult.tableidx = rand - 1;
			rollResult.v += d20.getTableElementValue(diceRoll.table, rollResult.tableidx);
		}
		else {
			rollResult.v += rand;
		}

		//Offset FATE rolls
		if (diceRoll.fate) {
			rollResult.v -= 2;
		}

		//Reduce roll by 1 for every extra penetrating roll
		if (diceRoll.mods && diceRoll.mods.penetrating != undefined && extraRollCounter > 0) {
			rollResult.v -= 1;
		}

		//Make sure we haven't exploded/compounded/penetrated/rerolled too many times
		if (extraRollCounter > MAX_NUM_ROLLS) {
			rollCompleteCallback();
		}
		else if (diceRoll.mods && diceRoll.mods.exploding != undefined && compareToPoint(rand, diceRoll.mods.exploding, diceRoll.sides)) {
			//Exploded - Roll an additional die
			rollDie(rollResult.i, diceRoll, rollCompleteCallback, extraRollCounter + 1);
		}
		else if (diceRoll.mods && diceRoll.mods.compounding != undefined && compareToPoint(rand, diceRoll.mods.compounding, diceRoll.sides)) {
			//Compounding - Roll another die but use the same rollResult
			asyncRand(diceRoll.sides, function(rand) {
				individualRollCallback(diceRoll, rollResult, rand, rollCompleteCallback, extraRollCounter + 1);
			}, (diceRoll.table !== undefined), diceRoll.rollid);
		}
		else if (diceRoll.mods && diceRoll.mods.penetrating != undefined && compareToPoint(rand, diceRoll.mods.penetrating, diceRoll.sides)) {
			//Exploded - Roll an additional die
			rollDie(rollResult.i, diceRoll, rollCompleteCallback, extraRollCounter + 1);
		}
		else if (diceRoll.mods && diceRoll.mods.reroll != undefined) {
			var rerolled = diceRoll.mods.reroll.some(function(reroll) {

				if (reroll.maxrerolls) {
					var numrollsforindex = 0;
					for (var jj = 0; jj < diceRoll.results.length; jj++) {
						if (diceRoll.results[jj].i === rollResult.i && diceRoll.results[jj].d === true) numrollsforindex++;
					}
				}

				if (compareToPoint(rand, reroll, 1)) {

					if (reroll.maxrerolls && numrollsforindex >= reroll.maxrerolls) {
						return false;
					}

					//Note that we
					//rerolled = true;
					rollResult.d = true;

					//ReRolled - Roll an additional die to replace the one that was dropped
					rollDie(rollResult.i, diceRoll, rollCompleteCallback, extraRollCounter + 1);

					//A true return stops iteration
					return true;
				}

				return false;
			});

			//If nothing was rerolled this die roll is complete
			if (!rerolled) {
				rollCompleteCallback();
			}
		}
		else {
			//No additional roll modifier, signal the die roll is complete
			rollCompleteCallback();
		}

		log(function() { return diceRollToString(diceRoll) + "\t - L individualRollCallback(" + extraRollCounter + ") " + rand; });
	};

	/**
	 * Apply all of the post-roll modifiers and perform totals
	 */
	var postProcessCompleteRolls = function(rolls, resultType, reprocess) {
		log(function() { return "E postProcessCompleteRolls"; });

		if (rolls.type == d20.dice.TYPE_VALIDATED_ROLLS) {
			// Special handling for the outer validated rolls data
			var total = postProcessCompleteRolls(rolls.rolls, rolls.resultType);
			rolls.total = total;
			return total;
		}

		var result = totalResults(rolls, resultType, reprocess);

		log(function() { return "L postProcessCompleteRolls - " + result; });
		return result;
	};

	var totalResults = function(rolls, resultType, reprocess, expression) {
		var expression = expression || new ExpressionBuilder();
		var expression = new ExpressionBuilder();
		for (var r = 0; r < rolls.length; r++) {
			totalResult(rolls[r], resultType, reprocess, expression);
		}
		return expression.eval();
	};

	var totalResult = function(roll, resultType, reprocess, expression) {
		var expression = expression || new ExpressionBuilder();
		if (roll.type == d20.dice.TYPE_ROLL_EXPR) {
			expression.startGroup();
			for (var d = 0; d < roll.results.length; d++) {
				if (!roll.results[d].d) {
					addResultValue(expression, resultType, roll.results[d].v, roll);
				}
			}
			expression.endGroup();
			// If we've got a match mod create a "matches" property with a random color assigned to the value if the number of matches meets threshold and comparison/point
			if(roll.mods.match) {
				var val_array = [];
				var match_obj = {};
				_.each(roll.results, function(r) {
					val_array.push(r["v"]);
				});
				var count_obj = val_array.reduce(function(countMap, value) {countMap[value] = ++countMap[value] || 1;return countMap}, {});
				var cur_count = 0;
				for(var k in count_obj) {
					if(count_obj[k] >= roll.mods.match.threshold) {
						if(!roll.mods.match.comp || !roll.mods.match.point || (roll.mods.match.comp === ">=" && k >= roll.mods.match.point) || (roll.mods.match.comp === "<=" && k <= roll.mods.match.point) || (roll.mods.match.comp === "==" && k == roll.mods.match.point)) {
							if(cur_count == 8) {cur_count = 0};
							match_obj[k] = d20.dice.MATCH_COLORS[cur_count];
							cur_count++;
						};
					};
				}
				roll.mods.match["matches"] = match_obj;
			}
		}
		else if (roll.type == d20.dice.TYPE_MATH_EXPR) {
			expression.addMathExpr(roll.expr);
		}
		else if (roll.type == d20.dice.TYPE_GROUP_EXPR) {
			expression.startGroup();
			if (!roll.d) {
				if (roll.results == undefined || reprocess) {
					roll.results = [];

					//For groups with 1 sub-roll that are have a success rollType use special to total each roll
					if (roll.rolls.length == 1 && resultType == d20.dice.ROLL_TYPE_SUCCESS) {

						//First step is to build up the math expressions to use before and after each roll result
						var mathPrefix = "";
						var rollExpression = undefined;
						var mathSuffix = "";
						for (var r = 0; r < roll.rolls[0].length; r++) {
							if (roll.rolls[0][r].type == d20.dice.TYPE_ROLL_EXPR) {
								if (rollExpression != undefined) {
									throw "Only one roll expression is allowed in a single sub-roll expression success check";
								}
								rollExpression = roll.rolls[0][r];
							}
							else if (roll.rolls[0][r].type == d20.dice.TYPE_MATH_EXPR) {
								if (rollExpression == undefined) {
									mathPrefix += roll.rolls[0][r].expr;
								}
								else {
									mathSuffix += roll.rolls[0][r].expr;
								}
							}
							else if (roll.rolls[0][r].type == d20.dice.TYPE_GROUP_EXPR) {
								throw roll.rolls[0][r].type + " expression is not supported in a single sub-roll expression success check";
							}
						}

						//Second step is to evaluate each roll with the math expressions and store the result in the group's results
						for (var r = 0; r < rollExpression.results.length; r++) {
							if (!rollExpression.results[r].d) {
								var rExp = new ExpressionBuilder();
								rExp.startGroup();
								rExp.addMathExpr(mathPrefix);
								rExp.addGroupValue(rollExpression.results[r].v);
								rExp.addMathExpr(mathSuffix);
								rExp.endGroup();

								roll.results.push(new GroupResult(rExp.eval()));
							}
						}
					}
					else {
						for (var g = 0; g < roll.rolls.length; g++) {
							var groupTotal = totalResults(roll.rolls[g], roll.resultType, reprocess);
							roll.results.push(new GroupResult(groupTotal));

							addResultValue(expression, resultType, groupTotal, roll);
						}
					}
				}
				else {
					roll.results.forEach(function(r) {
						if (!r.d) {
							addResultValue(expression, resultType, r.v, roll);
						}
					});
				}
			}
			expression.endGroup();
		}

		return expression;
	};

	var addResultValue = function(expression, resultType, value, roll) {
		if (resultType == d20.dice.ROLL_TYPE_SUM) {
			expression.addGroupValue(value);
		}
		else if (resultType == d20.dice.ROLL_TYPE_SUCCESS) {
			expression.addGroupSuccess(value, roll.mods.success);
			if (roll.mods && roll.mods.failure != undefined) {
				expression.addGroupFailure(value, roll.mods.failure);
			}
		}
		else if (resultType == d20.dice.ROLL_TYPE_MATCH) {
			expression.addGroupMatch(value, roll.mods.match);
		}
		else {
			throw "Unsupported resultType: " + resultType;
		}
	};

	/**
	 * reprocess an already processed roll result. Useful if structural changes such as reordering,
	 * or keep/drop toggling has been done and a recalculation of totals is needed
	 *
	 * @param rollResult The json object model returned to the finalCallback when the roll expression was originally processed
	 */
	this.reprocess = function(rollResult, finalCallback, errorCallback) {
		errorCallback = errorCallback || fallbackErrorHandler;

		try {
			postProcessCompleteRolls(rollResult, undefined, true);
			finalCallback(rollResult);
		}
		catch (e) {
			errorCallback(e);
		}
	};

	var remoteRollQueue = [];
	var remoteRollCallbacks = {};

	var performRemoteRoll = function(vre, rollid, rolltype, finalCallback, errorCallback) {
		remoteRollQueue.push({
			vre: vre,
			rollid: rollid,
			rolltype: rolltype
		});

		remoteRollCallbacks[rollid] = {
			success: finalCallback,
			error: errorCallback
		}

		debounced_doRemoteRollRequest();
	};

	var _doRemoteRollRequest = function() {

		if (remoteRollQueue.length === 0) return;

		if (!window.is_playerapp && window.currentPlayer.get("tddiceenabled") && window.currentPlayer.get("disableagency") === false) {

			if ($("#tdagencyoverlay").is(":visible")) {
				return;
			}
			$("#tdagencyoverlay").show();
			//DICECUP SFX
			var numberofdice = remoteRollQueue[0].vre.rolls[0].dice ? remoteRollQueue[0].vre.rolls[0].dice : 1;
			d20.tddice.playsound("dicecup", numberofdice);
			// d20.tddice.soundfx["dicecup.wav"].play();
			var posinfo = {};
			var $showline = $("#tdagencyoverlay svg line");
			var started_dragging = false;
			$("#tdagencyoverlay").on("mousedown", function(e) {
				posinfo.startx = e.clientX / $(window).width();
				posinfo.starty = e.clientY / $(window).height();
				$showline.attr("x1", e.clientX).attr("y1", e.clientY).attr("x2", e.clientX).attr("y2", e.clientY);
				started_dragging = true;
			});
			$("#tdagencyoverlay").on("mousemove", function(e) {
				if (started_dragging) {
					var xdist = Math.abs(posinfo.startx - (e.clientX / $(window).width()));
					var ydist = Math.abs(posinfo.starty - (e.clientY / $(window).height()));
					var curdist = Math.sqrt((xdist * xdist) + (ydist * ydist));
					if (curdist < 0.2) {
						$showline.css("stroke", "rgb(255,255,255)");
					}
					else if (curdist < 0.5) {
						$showline.css("stroke", "rgb(245,238,44)");
					}
					else {
						$showline.css("stroke", "rgb(245,44,44)");
					}
					$showline.attr("x2", e.clientX).attr("y2", e.clientY);
				}
			});
			$("#tdagencyoverlay").on("mouseup", function(e) {
				$("#tdagencyoverlay").off().hide();
				$showline.attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 0);
				firebase.auth().currentUser.getIdToken(false).then((token) => {
					if (!posinfo.startx) {
						_posthookrollrequest(null, token);
					}
					else {
						posinfo.stopx = e.clientX / $(window).width();
						posinfo.stopy = e.clientY / $(window).height();
						_posthookrollrequest(posinfo, token);
					}
				});
			})
		}
		else {
			setTimeout(function() {
				if(window.GNTKN === "tutorial") {
					_posthookrollrequest();
				} else {
					firebase.auth().currentUser.getIdToken(false).then((token) => {
						_posthookrollrequest(null, token);
					});
				}
			}, 50);
		}
	};

	var _posthookrollrequest = function(posinfo = {}, idToken) {
		if (remoteRollQueue.length === 0) return;

		var rolldata = {
			cid: window.campaign_storage_path,
			fbnum: window.FIREBASE_ROOT,
			authkey: idToken,
			pid: window.currentPlayer.id,
			rolls: remoteRollQueue,
			use3d: (window.is_playerapp ? window.currentPlayer.get("apptddiceenabled") : window.currentPlayer.get("tddiceenabled")),
		};

		if (posinfo) {

			var deltas = {
				x: posinfo.startx - posinfo.stopx,
				y: posinfo.starty - posinfo.stopy
			};

			var mindistance = 0.01;
			var maxdistance = 0.3;

			if (Math.abs(deltas["x"]) < mindistance) {
				deltas["x"] = deltas["x"] < 0 ? -mindistance : mindistance
			}
			if (Math.abs(deltas["y"]) < mindistance) {
				deltas["y"] = deltas["y"] < 0 ? -mindistance : mindistance
			}
			if (Math.abs(deltas["x"]) > maxdistance) {
				deltas["x"] = deltas["x"] < 0 ? -maxdistance : maxdistance
			}
			if (Math.abs(deltas["y"]) > maxdistance) {
				deltas["y"] = deltas["y"] < 0 ? -maxdistance : maxdistance
			}

			rolldata.deltas = {
				x: deltas.x * 80 * -1,
				y: deltas.y * 80 * 1
			};
		}
		else if (rolldata.use3d === true) {
			rolldata.deltas = {
				x: Math.random() * 10 - 5,
				y: 20
			};
		}

		const rollURL = window.ROLL_URL || 'https://dice.roll20.net';

		$.ajax({
			url: rollURL + "/doroll",
			type: "POST",
			data: JSON.stringify(rolldata),
			contentType: "application/json; charset=utf-8",
			dataType: "json",
			success: function(queueresults) {
				for (var resultrid in queueresults) {
					if (!remoteRollCallbacks[resultrid]){
						remoteRollCallbacks[resultrid] = {
							success: d20.textchat.roll_default_callback,
							error: d20.textchat.roll_error_callback
						}
					}

					d20.dice_engine.newRoll(resultrid);
					if (queueresults[resultrid].error != undefined) {
						remoteRollCallbacks[resultrid].error("There was an error fetching your roll. " + queueresults[resultrid].error);
						continue;
					}
					var thisvre = JSON.parse(queueresults[resultrid].json);
					postProcessCompleteRolls(thisvre);
					remoteRollCallbacks[resultrid].success(thisvre, resultrid, queueresults[resultrid].signature, queueresults[resultrid].tdseed);

					if (d20.tutorial && queueresults[resultrid].shoutjson !== undefined) {
						d20.tddice.remoteRoll(JSON.parse(queueresults[resultrid].shoutjson));
					}
				}
			},
			error: function(e) {
				//Fallback to local rolling.
				_.each(rolldata.rolls, function(thisroll) {

					var vre = thisroll.vre;

					var wholeRollCompleteCallback = new TaskCompletionCallback(vre.rolls.length, function() {
						postProcessCompleteRolls(vre);
						setTimeout(function() {
							remoteRollCallbacks[thisroll.rollid].success(vre, null, false);
						}, 0);
					}, "wholeRollCompleteCallback");

					initiateRolls(vre.rolls, vre.resultType, function() {
						wholeRollCompleteCallback.taskComplete();
					});
				});
			}
		});

		remoteRollQueue = [];
	};

	var numBounce = 0;
	function showWarning (obj, bounces) {
		var player = window.Campaign.players.get(obj.pid);
		d20.textchat.incoming(false, {
			who: "system",
			type: "system",
			content: i18n("warning_roll_results_missing_name_number").tranSub(player.get("displayname"), bounces)
		});
		numBounce = 0;
	}
	var showWarningTH = _.throttle(showWarning, 7000, { leading: false }); // The warning will only show up every 5 seconds.
	d20.dice_engine.handleRollReceived = function(obj) {
		// If the roll comes in before the shout, we don't have to worry about it at all
		if (recentRolls.indexOf(obj.rid) === -1) {
			setTimeout(function() {
				if (recentRolls.indexOf(obj.rid) === -1) {
					showWarningTH(obj, ++numBounce);
				}
				else {
					recentRolls.splice(recentRolls.indexOf(obj.rid), 1);
				}
			}, 3000)
		}
		else {
			recentRolls.splice(recentRolls.indexOf(obj.rid), 1);
		}
	};
	d20.dice_engine.newRoll = function(rollId) {
		if (recentRolls.indexOf(rollId) === -1) {
			recentRolls.push(rollId);
		}
	};

	this.flushRemoteQueue = function() {
		_doRemoteRollRequest();
	}

	var debounced_doRemoteRollRequest = _.debounce(_doRemoteRollRequest, 100);

	/**
	 * Process a roll expression and call finalCallback when complete with an
	 * object that contains the total, formula, and originalFormula
	 */
	this.process = function(rollString, finalCallback, errorCallback) {
		errorCallback = errorCallback || fallbackErrorHandler;

		try {
			var vre = parseRollString(rollString);

			if (vre.rolls == 0) {
				throw "There were no dice to roll!";
			}

			var didHaveTables = false;
			var didHaveRolls = false;
			var hasTablesDepth = 0;

			var hasTables = function(subrolls) {
				hasTablesDepth++;
				if (subrolls !== undefined) {
					for (var i = 0; i < subrolls.length; i++) {
						if (subrolls[i].table !== undefined) {
							didHaveTables = true;
						}
						if (subrolls[i].type === "R") {
							didHaveRolls = true;
						}
						if ((!didHaveTables || !didHaveRolls) && hasTablesDepth < 99 && subrolls[i].rolls !== undefined && subrolls[i].rolls.length > 0) {
							for (var j = 0; j < subrolls[i].rolls.length; j++) {
								hasTables(subrolls[i].rolls[j]);
							}
						}
					}
				}
			};

			try {
				hasTables(vre.rolls);
			}
			catch (e) {
			}

			hasTables = null;

			if (d20.textchat && d20.textchat.egg_clickhole) {
				didHaveTables = true; //force using local rolls.
			}

			if (didHaveTables === true || didHaveRolls === false) {
				var wholeRollCompleteCallback = new TaskCompletionCallback(vre.rolls.length, function() {
					postProcessCompleteRolls(vre);
					setTimeout(function() {
						finalCallback(vre, null, false);
					}, 0);
				}, "wholeRollCompleteCallback");

				initiateRolls(vre.rolls, vre.resultType, function() {
					wholeRollCompleteCallback.taskComplete();
				});
			}

			else if (typeof $ === "undefined") {
				//We're on the API server?

				var rollid = generateUUID();

				var rolldata = {
					vre: vre,
					cid: CAMPAIGNID,
					fbnum: 'https://' + FIREBASENUM + '.firebaseio.com/',
					pid: "api",
					rid: rollid,
					use3d: false,
					authkey: FIREBASETOKEN,
					rolltype: d20.textchat.currentRollType
				};

				// This is only needed until we are 100% on GKE
				const rollURL = window.ROLL_URL || "https://app.roll20.net";
				request.post({
					url: rollURL + "/doroll",
					body: rolldata,
					json: true,
					timeout: 5000
				}, function(error, response, body) {

					if (!error && response.statusCode == 200 && body !== "") {
						var snap = body;
						if (snap.error !== undefined) {
							errorCallback("There was an error fetching your roll. " + snap.error);
							return;
						}
						var finalvre = JSON.parse(snap.json);
						postProcessCompleteRolls(finalvre);
						finalCallback(finalvre, rollid, snap.signature);
					}

					else {
						errorCallback("There was an error communicating with the QuantumRoll server.");
					}
				});
			}

			else {

				var rollid = generateUUID();

				performRemoteRoll(vre, rollid, d20.textchat.currentRollType, finalCallback, errorCallback);
			}
		}
		catch (e) {
			errorCallback(e);
		}
	};

	this.handleRollReq = function(vre, finalCallback) {
		var wholeRollCompleteCallback = new TaskCompletionCallback(vre.rolls.length, function() {
			try {
				postProcessCompleteRolls(vre);
			}
			catch (e) {
				finalCallback({
					error: "There was an error processing this roll."
				});
				return;
			}
			setTimeout(function() {
				finalCallback(vre);
			}, 0);
		}, "wholeRollCompleteCallback");

		try {
			initiateRolls(vre.rolls, vre.resultType, function() {
				wholeRollCompleteCallback.taskComplete();
			});
		}
		catch (e) {
			finalCallback({
				error: "There was an error processing this roll."
			});
		}
	};

	this.handleRollString = function(rollString) {
		var vre = parseRollString(rollString);

		if (vre.rolls == 0) {
			throw "There were no dice to roll!";
		}

		return vre;
	}

	return this;
};